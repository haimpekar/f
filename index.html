// ==== CONSTANTS (Absolute Column Indices) ====
const USERS_SHEET = 'Users';
const STUDY_SET_SCHEMA = {
  term: 0,           // A
  image: 1,          // B
  band: 2,           // C
  definition: 3,     // D
  distractor1: 4,    // E
  distractor2: 5,    // F
  distractor3: 6     // G
};
const USER_PROGRESS_SCHEMA = {
  due: 0,
  step: 1,
  reps: 2,
  lapses: 3,
  suspended: 4,
  tags: 5,
};
const USER_SCHEMA = {
  userid: 0,
  userpwd: 1,
  themelight: 2,
  audioautoplay: 3,
  playbackspeed: 4,
  notes: 5,  
};
const GLOBAL_SETTINGS = ['ThemeLight', 'AudioAutoPlay', 'PlaybackSpeed'];

// Per-deck (per-set) user settings schema (stored as a 2-column KV matrix on the set sheet).
// This is used for validation/coercion, but unknown keys are preserved for backward-compat.
const USER_SET_SCHEMA = {
  UserID: { type: 'string', readonly: true },
  NewItemsPerDay: { type: 'number', min: 0, max: 10000 },
  TestDueDate: { type: 'string' },
  QuizMode: { type: 'boolean' },
  // Persisted daily cap counters (deck-scoped)
  DailyNewDayKey: { type: 'string' },      // YYYY-MM-DD (local day key decided by frontend)
  DailyNewCount: { type: 'number', min: 0, max: 100000 }
};
// Global user settings are returned to the frontend as a 2-column matrix in `userPreferences`.
// amazonq-ignore-next-line
const ADMIN_EMAIL = 'haim.pekar@gmail.com';
// amazonq-ignore-next-line
const FIRST_SET_ROW = Object.keys(USER_SCHEMA).length; // 0-based index of first set row (after UserID, UserPassword, global settings, Notes)
const USER_SETTINGS_START_ROW = 2; // Row where user settings begin (1-based)
const USER_SETTINGS_WIDTH = 2; // User settings use 2 columns (name, value)
const MAX_SETTINGS_SEARCH_ROWS = 40; // Max rows to search for metadata settings
const SHEET_DATA_CACHE = Object.create(null); // whole-sheet cache keyed by sheet name
const SHEET_OBJ_CACHE = Object.create(null); // sheet object cache
const USER_COL_CACHE = Object.create(null); // user column position cache: {sheetName_userId: colIndex}
// Legacy note: user blocks are located via explicit row-2 "UserID/email" anchor; no separate row cache.
const SHEET_METADATA_CACHE = Object.create(null); // sheet metadata cache: {sheetName: {DATA_START_ROW, USER_AREA_WIDTH}}
const APPEND_SHEET_CACHE = Object.create(null); // last row cache for append-only sheets: {sheetName: lastRow}
const DEBUG_LOG_MAX_ENTRIES = 200;
const DEBUG_LOG_MAX_CHARS = 50000;
const LOGIN_LOG_QUEUE_KEY = 'login_log_queue';
const LOGIN_LOG_CACHE_TTL_SECONDS = 1800; // 30 minutes
const LOGIN_LOG_MAX_SIZE = 25; // flush when queue hits this size
const LOGIN_LOG_MAX_AGE_MS = 5 * 60 * 1000; // or when oldest entry is this old
const LOGIN_LOG_HARD_LIMIT = 75; // guardrail to cap cache size

function _coerceBoolean_(v) {
  if (typeof v === 'boolean') return v;
  const s = String(v ?? '').trim().toLowerCase();
  if (s === 'true' || s === '1' || s === 'yes' || s === 'y') return true;
  if (s === 'false' || s === '0' || s === 'no' || s === 'n') return false;
  return !!v;
}

function _coerceNumber_(v) {
  const n = (typeof v === 'number') ? v : Number(String(v ?? '').trim());
  return Number.isFinite(n) ? n : 0;
}

function normalizeUserSetSettings_(rows, userId) {
  if (!Array.isArray(rows)) return [];
  const out = rows.map(r => {
    if (!Array.isArray(r)) return ['', ''];
    const key = String(r[0] ?? '').trim();
    const val = r.length > 1 ? r[1] : '';

    // Ignore header/user rows that should never be saved as deck-scoped settings.
    // (Global preferences use 'Setting|Value'; some sheets/UI may show 'Settings|Value'.)
    if (!key || key === 'Setting' || key === 'Settings' || key === 'Password') return ['', ''];

    if (key === 'UserID') {
      return ['UserID', String(userId)];
    }

    const spec = USER_SET_SCHEMA[key];
    if (!spec) {
      // Unknown key: preserve but sanitize value type to primitives/strings.
      if (val === null || val === undefined) return [key, ''];
      if (typeof val === 'boolean' || typeof val === 'number') return [key, val];
      if (val instanceof Date) return [key, val];
      return [key, String(val)];
    }

    let coerced = val;
    if (spec.type === 'boolean') {
      coerced = _coerceBoolean_(val);
    } else if (spec.type === 'number') {
      coerced = _coerceNumber_(val);
      if (typeof spec.min === 'number') coerced = Math.max(spec.min, coerced);
      if (typeof spec.max === 'number') coerced = Math.min(spec.max, coerced);
    } else {
      coerced = (val === null || val === undefined) ? '' : String(val);
    }

    // Light validation for day keys (frontend decides locale; we store YYYY-MM-DD string)
    if (key === 'DailyNewDayKey') {
      const s = String(coerced ?? '').trim();
      coerced = /^\d{4}-\d{2}-\d{2}$/.test(s) ? s : '';
    }

    return [key, coerced];
  });

  // Enforce: UserID is always the first settings row (sheet row 2) and never changes matrix length.
  // This prevents accidental expansion (e.g., unshift) which can overwrite header/progress rows.
  if (out.length > 0) {
    out[0] = ['UserID', String(userId)];
  }

  return out;
}

// getCallerId_() → derives userId from Session.getActiveUser() or payload

// getSession()
//   ├→ getCallerId_() → get userId
//   ├→ resolveActiveSetSheet_() → get active set sheet name
//   │   └→ readActiveUserConfig_() → cache Users sheet, find user row
//   │       └→ getSheetData_() → load SETTINGS_SHEET into cache
//   ├→ parseSetSheet_() → parse sheet into structured data
//   │   ├→ getSheetData_() → load active set sheet into cache
//   │   ├→ entriesToObject_() → convert metadata rows to settings object
//   │   └→ Extract userSettings, userProgress, cards using direct slicing
//   ├→ getAvailableSetNames_() → extract set names from Users header
//   └→ Return: {userId, activeSet, availableSets, setSettings, cards, userSettings, userProgress}


// saveSession(payload)
//   ├→ getCallerId_() → get userId
//   ├→ resolveActiveSetSheet_() → resolve sheet name
//   ├→ parseSetSheet_() → get sheet layout (dataStartRow, USER_AREA_WIDTH)
//   ├→ writeUserSettings_() (if userSettings in payload)
//   │   ├→ findUserDataStartCol_() → locate user's data column block
//   │   ├→ sh().getRange().setValues() → write settings to sheet
//   │   └→ setCachedCells_() → update in-memory cache
//   └→ writeUserProgress_() (if userProgress in payload)
//       ├→ findUserDataStartCol_() → locate user's data column block
//       ├→ sh().getRange().setValues() → write progress to sheet
//       └→ setCachedCells_() → update in-memory cache

// buildDistractorsCache()
//   ├→ Get active sheet
//   ├→ getSheetData_() → check DistractorsAsReference setting
//   ├→ parseSetSheet_() → get card data
//   ├→ pickFor() → find N similar terms for each card
//   │   ├→ Filter pool by term length similarity
//   │   ├→ Score candidates with jaroWinkler_()
//   │   └→ Return sheet row numbers (1-based)
//   └→ sh().getRange().setValues() → write distractor row references (columns E-G)


// Purpose: find header row by searching for "Term" in column A.
// Inputs: sheetData (cache entry with values array).
// Outputs: 1-based row number where "Term" is found, or null.
// Flow: Called by parseSetSheet_, getSheetMetadata_.
function findHeaderRow_(sheetData) {
  const allRows = sheetData.values || [];
  for (let i = 0; i < Math.min(allRows.length, MAX_SETTINGS_SEARCH_ROWS); i++) {
    const cellValue = String(allRows[i][0] || '').trim().toLowerCase();
    if (cellValue === 'term') {
      return i + 1; // Return 1-based row number
    }
  }
  return null;
}

// Purpose: find user settings column by searching row 2 for userId email.
// Inputs: allRows (2D array), userId (string), sheetName (optional for caching).
// Outputs: 0-based column index of user settings start, or null if not found.
// Flow: Called by parseSetSheet_, writeUserSettings_, writeUserProgress_.
function findUserSettingsCol_(allRows, userId, sheetName) {
  if (sheetName && userId) {
    const cacheKey = `${sheetName}_${userId}`.toLowerCase();
    if (USER_COL_CACHE[cacheKey] !== undefined) {
      Logger.log('[findUserSettingsCol_] Cache hit for ' + userId + ': col=' + USER_COL_CACHE[cacheKey]);
      return USER_COL_CACHE[cacheKey];
    }
  }
  
  if (!allRows || allRows.length < 2) {
    Logger.log('[findUserSettingsCol_] Not enough rows: ' + (allRows?.length || 0));
    return null;
  }
  
  // Sheet layout (important): each user owns ONE contiguous block of USER_PROGRESS_SCHEMA columns (typically 6).
  // The *same columns* are used for settings above the header row (key/value in the first two columns)
  // and for progress below the header row.
  // Therefore we identify the user block start by finding, on row 2:
  //   col c     == 'UserID'   (first column of the block)
  //   col c + 1 == user_email (second column of the block)
  const userIdRow = allRows[1] || [];  // Row 2 contains user settings key/value pairs per user block
  const targetUserId = String(userId || '').trim().toLowerCase();
  const dataWidth = Object.keys(STUDY_SET_SCHEMA).length;
  const blockWidth = Object.keys(USER_PROGRESS_SCHEMA).length;

  const startCol = dataWidth; // user blocks are to the right of the card columns
  Logger.log('[findUserSettingsCol_] Searching for user block: ' + targetUserId + ' in row 2 from col ' + startCol);

  // Do NOT assume blocks are perfectly packed with no gaps; scan for the exact anchor.
  for (let col = startCol; col + 1 < userIdRow.length; col++) {
    const k = String(userIdRow[col] || '').trim().toLowerCase();
    const v = String(userIdRow[col + 1] || '').trim().toLowerCase();
    if (k === 'userid' && v === targetUserId) {
      Logger.log('[findUserSettingsCol_] Found block at col ' + col);
      if (sheetName && userId) {
        const cacheKey = `${sheetName}_${userId}`.toLowerCase();
        USER_COL_CACHE[cacheKey] = col;
      }
      return col;
    }
  }
  Logger.log('[findUserSettingsCol_] Not found, returning null');
  return null;
}

function provisionUserColumns_(sheetName, userId, headerRow) {
  if (!sheetName) throw new Error('sheetName is required');
  if (!userId) throw new Error('userId is required');
  if (!headerRow || headerRow < 2) throw new Error('headerRow is required to provision user columns');

  const sh = getSheet_(sheetName);
  const lastCol = sh.getLastColumn();
  const startCol1 = lastCol + 1; // 1-based

  const progressHeaders = Object.keys(USER_PROGRESS_SCHEMA);
  const progressWidth = progressHeaders.length;

  // Create the full user block width (progressWidth columns). Settings live in the first 2 columns,
  // but the block itself is progressWidth columns wide.

  // Progress header row: begins at the block start (same columns as settings).
  sh.getRange(headerRow, startCol1, 1, progressWidth).setValues([progressHeaders]);

  // Settings header row (row 1 of the sheet, in the new user block)
  // This is for human readability; the app still reads/writes settings from row 2 down.
  sh.getRange(1, startCol1, 1, USER_SETTINGS_WIDTH).setValues([['Settings', 'Value']]);

  // Settings rows (row 2 .. row before headerRow): write defaults into the first 2 columns of the block.
  const settingsRowCount = Math.max(0, headerRow - USER_SETTINGS_START_ROW);
  if (settingsRowCount > 0) {
    const out = Array.from({ length: settingsRowCount }, () => ['', '']);
    const defaults = [
      ['UserID', String(userId).trim().toLowerCase()],
      ['NewItemsPerDay', 5],
      ['QuizMode', true],
      ['TestDueDate', '2000-01-01'],
      ['DailyNewDayKey', ''],
      ['DailyNewCount', 0]
    ];
    for (let i = 0; i < Math.min(out.length, defaults.length); i++) {
      out[i] = defaults[i];
    }
    sh.getRange(USER_SETTINGS_START_ROW, startCol1, settingsRowCount, USER_SETTINGS_WIDTH).setValues(out);
  }

  const settingsCol0 = startCol1 - 1;
  USER_COL_CACHE[`${sheetName}_${userId}`.toLowerCase()] = settingsCol0;
  return settingsCol0;
}



// Purpose: create a consistent, normalized key for the sheet cache.
// Inputs: sheetName (string).
// Outputs: a trimmed, lowercased string.
// Flow: Called by getSheetData_, preloadSheet_, invalidateSheetCache_.
function _normalizeSheetCacheKey_(sheetName) {
  const key = String(sheetName || '').trim().toLowerCase();
  if (!key) throw new Error('Sheet name is required');
  return key;
}

// Purpose: get cached sheet object or fetch it.
// Inputs: sheetName (string).
// Outputs: Sheet object.
function getSheet_(sheetName) {
  const key = _normalizeSheetCacheKey_(sheetName);
  // amazonq-ignore-next-line
  if (!SHEET_OBJ_CACHE[key]) {
    const t0 = Date.now();
    SHEET_OBJ_CACHE[key] = sh_(sheetName);
    Logger.log(`[SHEET→BACK] GET_SHEET ${sheetName} ${Date.now()-t0}ms`);
  }
  return SHEET_OBJ_CACHE[key];
}

// Purpose: load a sheet's entire data into the cache.
// Inputs: sheetName (string).
// Outputs: a cache entry object containing sheet data and metadata.
// Flow: Called by getSheetData_. Calls: _normalizeSheetCacheKey_, getSheet_.
function preloadSheet_(sheetName) {
  const t0 = Date.now();
  const key = _normalizeSheetCacheKey_(sheetName);
  
  // Try CacheService first (persists across executions)
  if (sheetName === USERS_SHEET) {
    try {
      const cache = CacheService.getScriptCache();
      const cached = cache.get('sheet_' + key);
      if (cached) {
        const entry = JSON.parse(cached);
        SHEET_DATA_CACHE[key] = entry;
        Logger.log(`[SHEET→BACK] READ ${sheetName} ${entry.values.length}×${entry.values[0]?.length || 0} CACHED ${Date.now()-t0}ms`);
        return entry;
      }
    } catch (e) {
      Logger.log('[preloadSheet_] CacheService read failed: ' + e.message);
    }
  }
  
  const sh = getSheet_(sheetName);
  const t1 = Date.now();
  const dataRange = sh.getDataRange();
  const t2 = Date.now();
  const values = dataRange.getValues();
  const t3 = Date.now();
  const lastRow = values.length;
  const lastCol = values.length > 0 ? values[0].length : 0;
  const entry = {
    key,
    name: sheetName,
    values,
    fetchedAt: Date.now()
  };
  SHEET_DATA_CACHE[key] = entry;
  
  // Cache Users sheet in CacheService (6 hour TTL)
  if (sheetName === USERS_SHEET) {
    try {
      const cache = CacheService.getScriptCache();
      cache.put('sheet_' + key, JSON.stringify(entry), 21600); // 6 hours
    } catch (e) {
      Logger.log('[preloadSheet_] CacheService write failed: ' + e.message);
    }
  } else {
    // Cache header + metadata for study set sheets
    try {
      const cache = CacheService.getScriptCache();
      const header = values[0] || [];
      const useridRow = values[1] || [];
      // Auto-detect DATA_START_ROW by finding "Term" in column A
      const headerRow = findHeaderRow_(entry);
      const DATA_START_ROW = headerRow ? headerRow + 1 : null;
      const headerCache = { header, useridRow, DATA_START_ROW, USER_AREA_WIDTH: Object.keys(USER_PROGRESS_SCHEMA).length };
      cache.put('header_' + key, JSON.stringify(headerCache), 21600);
    } catch (e) {
      Logger.log('[preloadSheet_] Header cache write failed: ' + e.message);
    }
  }
  
  Logger.log(`[SHEET→BACK] READ ${sheetName} ${lastRow}×${lastCol} total=${Date.now()-t0}ms (getDataRange=${t2-t1}ms, getValues=${t3-t2}ms)`);
  return entry;
}

// Purpose: retrieve sheet data from the cache, loading it if necessary.
// Inputs: sheetName (string).
// Outputs: a cache entry object.
// Flow: Called by many functions needing sheet data. Calls: _normalizeSheetCacheKey_, preloadSheet_.
function getSheetData_(sheetName) {
  const key = _normalizeSheetCacheKey_(sheetName);  
  if (!SHEET_DATA_CACHE[key]) {
    return preloadSheet_(sheetName);
  }
  return SHEET_DATA_CACHE[key];
}

// Purpose: update values in the cache for a given sheet entry.
// Inputs: entry (cache entry object), startRow (1-based), startCol (1-based), values (2D array).
// Outputs: none (side effect: modifies cache entry).
// Flow: Called by writeUserSettings_, writeUserProgress_.
function setCachedCells_(entry, startRow, startCol, values) {
  // amazonq-ignore-next-line
  if (!entry || !Array.isArray(values) || !values.length) return;
  const startRowIdx = startRow - 1;
  const startColIdx = startCol - 1;
  // amazonq-ignore-next-line
  for (let r = 0; r < values.length; r++) {
    const targetRow = entry.values[startRowIdx + r];
    const cells = Array.isArray(values[r]) ? values[r] : [values[r]];
    for (let c = 0; c < cells.length; c++) {
      targetRow[startColIdx + c] = cells[c];
    }
  }
  entry.fetchedAt = Date.now();
}

// Purpose: invalidate (clear) the cache for a specific sheet.
// Inputs: sheetName (string).
// Outputs: none (side effect: removes cache entry).
// Flow: Called after updating Users sheet to force reload.
function invalidateSheetCache_(sheetName) {
  const key = _normalizeSheetCacheKey_(sheetName);
  // amazonq-ignore-next-line
  delete SHEET_DATA_CACHE[key];
  
  // Clear CacheService
  try {
    const cache = CacheService.getScriptCache();
    if (sheetName === USERS_SHEET) {
      cache.remove('sheet_' + key);
    } else {
      cache.remove('header_' + key);
    }
  } catch (e) {
    Logger.log('[invalidateSheetCache_] CacheService clear failed: ' + e.message);
  }
  
  Logger.log('[invalidateSheetCache_] Cleared cache for: ' + sheetName);
}

// Purpose: read the requested user column from the Users sheet.
// Inputs: userId (string to locate the user column).
// Outputs: column array for the matching user.
// Flow: Called by getAvailableSetNames_; Calls: getSheetData_.
function readActiveUserConfig_(userId) {
  if (!userId) throw new Error('userId is required');
  
  const sheetData = getSheetData_(USERS_SHEET);
  const allData = sheetData.values || [];  
  
  // amazonq-ignore-next-line
  if (allData.length < 1) {
    throw new Error('Users sheet is empty');
  }
  
  const userIdRow = allData[0] || [];  // Row 1 contains user emails
  const targetUserId = String(userId).trim().toLowerCase();
  Logger.log('[readActiveUserConfig_] Looking for user: ' + targetUserId);
  
  for (let col = 1; col < userIdRow.length; col++) {
    const colUserId = String(userIdRow[col] || '').trim().toLowerCase();
    if (colUserId === targetUserId) {
      Logger.log('[readActiveUserConfig_] Found user at column ' + (col + 1));
      return allData.map(row => {
        if (!row || row.length <= col) return '';
        const v = row[col];
        return (v === undefined || v === null) ? '' : v;
      });
    }
  }
  throw new Error(`User ${userId} not found in Users sheet`);
}

// Purpose: save user feedback to Feedback sheet.
// Inputs: userId (string), currentSet (string), message (string).
// Outputs: none (side effect: appends row to Feedback sheet).
// Flow: Called by saveSession when saveType is 'feedback'.
function saveFeedback_(userId, currentSet, message) {
  const t0 = Date.now();
  const SHEET_NAME = 'Feedback';
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let feedbackSheet = ss.getSheetByName(SHEET_NAME);
  
  if (!feedbackSheet) {
    feedbackSheet = ss.insertSheet(SHEET_NAME);
    feedbackSheet.getRange(1, 1, 1, 4).setValues([['Timestamp', 'UserID', 'CurrentSet', 'Message']]);
    APPEND_SHEET_CACHE[SHEET_NAME] = 1;
  }
  
  // Get next row from cache or sheet
  // amazonq-ignore-next-line
  // amazonq-ignore-next-line
  let nextRow = APPEND_SHEET_CACHE[SHEET_NAME];
  if (!nextRow) {
    nextRow = feedbackSheet.getLastRow();
    APPEND_SHEET_CACHE[SHEET_NAME] = nextRow;
  }
  nextRow++;
  
  const timestamp = new Date();
  const setName = currentSet || '';
  feedbackSheet.getRange(nextRow, 1, 1, 4).setValues([[timestamp, userId, setName, message]]);
  APPEND_SHEET_CACHE[SHEET_NAME] = nextRow;
  
  Logger.log(`[BACK→SHEET] WRITE Feedback 1×4 ${Date.now()-t0}ms`);
}

// Purpose: return ALL set names from first column (for new user registration).
// Inputs: none.
// Outputs: array of all set names.
// Flow: Called by getSession for new user registration.
function getAllSetNames_() {
  const sheetData = getSheetData_(USERS_SHEET);
  const allData = sheetData.values || [];
  // Rows 1-6 = user data, Row 7+ = set names
  return allData.slice(FIRST_SET_ROW).map(row => String(row[0] || '').trim()).filter(Boolean);
}

// Purpose: return the set names available for the caller.
// Inputs: userId (required).
// Outputs: array of set names the user has access to (TRUE permissions).
// Flow: Called by getSession; Calls: readActiveUserConfig_.
function getAvailableSetNames_(userId) {
  if (!userId) throw new Error('userId is required for getAvailableSetNames_');
  const userCol = readActiveUserConfig_(userId);
  const sheetData = getSheetData_(USERS_SHEET);
  const allData = sheetData.values || [];
  
  const availableSets = [];
  // Rows 1-6 = user data, Row 7+ = set names
  for (let row = FIRST_SET_ROW; row < allData.length; row++) {
    const setName = String(allData[row][0] || '').trim();
    // amazonq-ignore-next-line
    if (setName && userCol[row] === true) {
      availableSets.push(setName);
    }
  }
  Logger.log('[getAvailableSetNames_] User "' + userId + '" has access to ' + availableSets.length + ' sets: ' + JSON.stringify(availableSets));
  return availableSets;
}

// Purpose: log login attempt to Log sheet.
// Inputs: email (string), status (string).
// Outputs: none (side effect: writes to sheet).
function logLoginAttempt_(email, status) {
  try {
    const SHEET_NAME = 'Log';
    const ss = getSs_();
    let logSheet = ss.getSheetByName(SHEET_NAME);
    
    if (!logSheet) {
      // amazonq-ignore-next-line
      logSheet = ss.insertSheet(SHEET_NAME);
      logSheet.getRange(1, 1, 1, 3).setValues([['Timestamp', 'Email', 'Status']]);
      APPEND_SHEET_CACHE[SHEET_NAME] = 1;
    }
    
    // Get next row from cache or sheet
    let nextRow = APPEND_SHEET_CACHE[SHEET_NAME];
    if (!nextRow) {
      nextRow = logSheet.getLastRow();
      APPEND_SHEET_CACHE[SHEET_NAME] = nextRow;
    }
    nextRow++;
    
    logSheet.getRange(nextRow, 1, 1, 3).setValues([[new Date(), email, status]]);
    APPEND_SHEET_CACHE[SHEET_NAME] = nextRow;
  } catch (e) {
    Logger.log('Failed to log login attempt: ' + e.message);
  }
}

function clearInMemoryCaches_() {
  [SHEET_DATA_CACHE, SHEET_OBJ_CACHE, USER_COL_CACHE, SHEET_METADATA_CACHE, APPEND_SHEET_CACHE].forEach(cache => {
    for (const key in cache) delete cache[key];
  });
}

function clearScriptCacheEntries_(sheetKeys) {
  try {
    const cache = CacheService.getScriptCache();
    const keysToRemove = [LOGIN_LOG_QUEUE_KEY];
    sheetKeys.forEach(key => {
      keysToRemove.push('sheet_' + key, 'header_' + key);
    });
    const uniqueKeys = Array.from(new Set(keysToRemove));
    if (uniqueKeys.length) cache.removeAll(uniqueKeys);
  } catch (e) {
    Logger.log('[clearScriptCacheEntries_] ' + e.message);
  }
}

function clearAllCachesAndQueues_() {
  const sheetKeys = Object.keys(SHEET_DATA_CACHE);
  clearInMemoryCaches_();
  clearScriptCacheEntries_(sheetKeys);
  APPEND_SHEET_CACHE.__lastCleared = Date.now();
  Logger.log('[Back] Cleared in-memory caches and script cache queue');
}

// Lightweight admin-only debug collector
function makeDebugBuffer_(enabled) {
  return enabled ? { enabled: true, entries: [], total: 0 } : null;
}

function debugLog_(dbg, msg) {
  if (!dbg || !dbg.enabled) return;
  const text = String(msg ?? '');
  if (dbg.entries.length >= DEBUG_LOG_MAX_ENTRIES) return;
  if (dbg.total + text.length > DEBUG_LOG_MAX_CHARS) return;
  dbg.entries.push(text);
  dbg.total += text.length;
}

function attachDebug_(dbg, obj) {
  if (dbg && dbg.enabled && dbg.entries.length) {
    obj.debugLog = dbg.entries.slice();
  }
  return obj;
}

// Purpose: queue login attempts in CacheService and flush opportunistically.
// Inputs: email (string), status (string).
// Outputs: number of entries currently queued.
function enqueueLoginAttempt_(email, status) {
  try {
    const cache = CacheService.getScriptCache();
    const now = Date.now();
    let queue = [];
    const raw = cache.get(LOGIN_LOG_QUEUE_KEY);
    if (raw) {
      try {
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) queue = parsed;
      } catch (e) {
        Logger.log('[enqueueLoginAttempt_] Failed to parse cache: ' + e.message);
      }
    }

    queue.push({ ts: now, email: String(email || ''), status: String(status || '') });
    // amazonq-ignore-next-line
    if (queue.length > LOGIN_LOG_HARD_LIMIT) {
      queue = queue.slice(-LOGIN_LOG_HARD_LIMIT);
    }

    const oldestTs = queue[0]?.ts || now;
    const shouldFlush = queue.length >= LOGIN_LOG_MAX_SIZE || (now - oldestTs) >= LOGIN_LOG_MAX_AGE_MS;

    cache.put(LOGIN_LOG_QUEUE_KEY, JSON.stringify(queue), LOGIN_LOG_CACHE_TTL_SECONDS);
    if (shouldFlush) {
      flushLoginLogQueue_(false);
    }

    return queue.length;
  // amazonq-ignore-next-line
  } catch (e) {
    Logger.log('[enqueueLoginAttempt_] ' + e.message);
    return 0;
  }
}

// Purpose: flush queued login attempts to Log sheet if forced or thresholds met.
// Inputs: force (boolean) – flush even if under thresholds.
// Outputs: number of rows written.
function flushLoginLogQueue_(force) {
  try {
    const cache = CacheService.getScriptCache();
    const raw = cache.get(LOGIN_LOG_QUEUE_KEY);
    if (!raw) return 0;

    let queue = [];
    try {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) queue = parsed;
    } catch (e) {
      Logger.log('[flushLoginLogQueue_] Failed to parse cache: ' + e.message);
      cache.remove(LOGIN_LOG_QUEUE_KEY);
      return 0;
    }

    if (!queue.length) {
      cache.remove(LOGIN_LOG_QUEUE_KEY);
      return 0;
    }

    const now = Date.now();
    const oldestTs = queue[0]?.ts || now;
    const shouldFlush = force || queue.length >= LOGIN_LOG_MAX_SIZE || (now - oldestTs) >= LOGIN_LOG_MAX_AGE_MS;
    if (!shouldFlush) return 0;

    const SHEET_NAME = 'Log';
    const ss = getSs_();
    let logSheet = ss.getSheetByName(SHEET_NAME);
    if (!logSheet) {
      logSheet = ss.insertSheet(SHEET_NAME);
      logSheet.getRange(1, 1, 1, 3).setValues([['Timestamp', 'Email', 'Status']]);
      APPEND_SHEET_CACHE[SHEET_NAME] = 1;
    }

    let nextRow = APPEND_SHEET_CACHE[SHEET_NAME];
    if (!nextRow) {
      nextRow = logSheet.getLastRow();
      APPEND_SHEET_CACHE[SHEET_NAME] = nextRow;
    }

    const rows = queue.map(entry => [
      entry.ts ? new Date(entry.ts) : new Date(),
      entry.email || '',
      entry.status || ''
    ]);

    logSheet.getRange(nextRow + 1, 1, rows.length, 3).setValues(rows);
    APPEND_SHEET_CACHE[SHEET_NAME] = nextRow + rows.length;
    cache.remove(LOGIN_LOG_QUEUE_KEY);

    // amazonq-ignore-next-line
    Logger.log(`[BACK'SHEET] WRITE Log ${rows.length} rows`);
    return rows.length;
  } catch (e) {
    Logger.log('[flushLoginLogQueue_] ' + e.message);
    return 0;
  }
}

// Purpose: validate user credentials against Users sheet.
// Inputs: email (string), password (string).
// Outputs: 'SUCCESS', 'USER_NOT_FOUND', or 'WRONG_PASSWORD'.
function validateCredentials_(email, password) {
  if (!email || !password) return 'USER_NOT_FOUND';
  
  const sheetData = getSheetData_(USERS_SHEET);
  const allData = sheetData.values || [];
  
  if (allData.length < 2) {
    return 'USER_NOT_FOUND';
  }
  
  const userIdRow = allData[0] || [];  // Row 1 contains emails
  const pwdRow = allData[1] || [];     // Row 2 contains passwords
  
  if (userIdRow.length < 2) {
    return 'USER_NOT_FOUND';
  }
  
  const targetEmail = String(email).trim().toLowerCase();
  const targetPwd = String(password).trim();
  
  for (let col = 1; col < userIdRow.length; col++) {
    const colEmail = String(userIdRow[col] || '').trim().toLowerCase();
    const colPwd = String(pwdRow[col] || '').trim();
    
    if (colEmail === targetEmail) {
      return colPwd === targetPwd ? 'SUCCESS' : 'WRONG_PASSWORD';
    }
  }
  
  return 'USER_NOT_FOUND';
}

// Purpose: derive a stable caller identity string.
// Inputs: arg (required payload containing userId and password).
// Outputs: normalized userId or throws error with specific message.
// Flow: Called by getSession and saveSession; validates credentials and logs attempts.
function getCallerId_(arg) {
  if (!arg || typeof arg !== 'object' || !arg.userId || !arg.password) {
    throw new Error('USER_NOT_FOUND');
  }
  
  const email = String(arg.userId).toLowerCase();
  // amazonq-ignore-next-line
  const password = String(arg.password);
  
  const status = validateCredentials_(email, password);
  // Queue login attempt for opportunistic flush (avoids blocking request)
  enqueueLoginAttempt_(email, status);
  
  if (status === 'SUCCESS') {
    return email;
  }
  
  throw new Error(status); // Will be 'USER_NOT_FOUND' or 'WRONG_PASSWORD'
}

// Purpose: convert 2-column entries into a key/value map.
// Inputs: entries (array of [key,value] rows).
// Outputs: object mapping keys to values.
// Flow: Called by parseSetSheet_; Calls: none.
function entriesToObject_(entries) {
  const obj = {};
  if (!Array.isArray(entries)) return obj;
  for (const entry of entries) {
    if (!Array.isArray(entry) || !entry.length) continue;
    const key = String(entry[0] || '').trim();
    if (!key) continue;
    obj[key] = entry.length > 1 ? entry[1] : '';
  }
  return obj;
}

// Purpose: parse the studySet sheet into structured data for the UI.
// Inputs: sheetName (string) of the active set.
// Outputs: object with setSettings, userSettings, userProgress, cards.
// Flow: Called by getSession, saveSession; Calls: getSheetData_, entriesToObject_.
function parseSetSheet_(sheetName, userId) {
  const sheetData = getSheetData_(sheetName);
  const allRows = sheetData.values || [];
  if (allRows.length < 2) {
    return {
      setSettings: {},
      userSettings: [],
      userProgress: [],
      cards: []
    };
  }

  // Auto-detect DATA_START_ROW by finding "Term" in column A
  const headerRow = findHeaderRow_(sheetData);
  const dataStartRow = headerRow ? headerRow + 1 : null;

  // Collect settings from rows before header
  const setSettingsEntries = [];
  const endRow = headerRow ? headerRow - 1 : Math.min(allRows.length, MAX_SETTINGS_SEARCH_ROWS);
  for (let i = 1; i < endRow; i++) {
    const row = allRows[i];
    const setKey = String(row[0] || '').trim();
    if (setKey) {
      setSettingsEntries.push([setKey, row[1]]);
    }
  }

  const setSettings = entriesToObject_(setSettingsEntries);
  // Add DATA_START_ROW to setSettings for compatibility
  if (dataStartRow) {
    setSettings.DATA_START_ROW = dataStartRow;
  }
  // amazonq-ignore-next-line
  const userAreaWidth = Object.keys(USER_PROGRESS_SCHEMA).length;
  
  // Find user's settings and progress areas
  // Header row is where "Term" is found (headerRow - 1 in 0-based indexing)
  const headerIdx = headerRow ? headerRow - 1 : 0;
  let userSettingsCol = null;
  let userProgressCol = null;
  let allRowsUpdated = null;
  
  if (userId && userAreaWidth) {
    Logger.log('[parseSetSheet_] Looking for user columns for: ' + userId);
    userSettingsCol = findUserSettingsCol_(allRows, userId, sheetName);
    Logger.log('[parseSetSheet_] findUserSettingsCol_ returned: ' + userSettingsCol);

    // Auto-provision missing user column block.
    if (userSettingsCol === null) {
      if (!headerRow || !dataStartRow) {
        throw new Error(`User columns not found for ${userId} in sheet ${sheetName} (and cannot provision: missing header)`);
      }
      Logger.log('[parseSetSheet_] Provisioning new user columns for ' + userId + ' in sheet ' + sheetName);
      provisionUserColumns_(sheetName, userId, headerRow);

      // Refresh cached sheet data so we can extract the newly-created block.
      invalidateSheetCache_(sheetName);
      const sheetData2 = getSheetData_(sheetName);
      allRowsUpdated = sheetData2.values || [];
      userSettingsCol = findUserSettingsCol_(allRowsUpdated, userId, sheetName);
      Logger.log('[parseSetSheet_] After provision, userSettingsCol=' + userSettingsCol);
      if (userSettingsCol === null) {
        throw new Error(`Provisioned user columns but still not found for ${userId} in sheet ${sheetName}`);
      }
    }

    // Progress shares the same columns as the user block (it is below the settings, not to the right).
    userProgressCol = userSettingsCol;

    // Legacy cleanup (one user block, row 2 only): older versions wrote the user's email as a "marker"
    // inside the same block in columns 3..6 on row 2. In this layout, row 2 should only use
    // the first two columns (Setting/Value) for settings.
    try {
      const rowsForCleanup = (allRowsUpdated !== null && allRowsUpdated !== undefined) ? allRowsUpdated : allRows;
      const row2 = rowsForCleanup[1] || [];
      const target = String(userId || '').trim().toLowerCase();
      const blockWidth = userAreaWidth;
      const extraStart0 = userSettingsCol + USER_SETTINGS_WIDTH;
      const extraWidth = Math.max(0, blockWidth - USER_SETTINGS_WIDTH);

      if (extraWidth > 0) {
        let needsWrite = false;
        const newExtra = [];
        for (let i = 0; i < extraWidth; i++) {
          const col0 = extraStart0 + i;
          const v = row2[col0];
          const s = String(v ?? '').trim().toLowerCase();
          if (s && s === target) {
            newExtra.push('');
            needsWrite = true;
          } else {
            newExtra.push(v);
          }
        }

        if (needsWrite) {
          const sh = getSheet_(sheetName);
          sh.getRange(2, extraStart0 + 1, 1, extraWidth).setValues([newExtra]);

          // Keep in-memory cache consistent.
          const entry = SHEET_DATA_CACHE[_normalizeSheetCacheKey_(sheetName)];
          if (entry && entry.values && entry.values[1]) {
            for (let i = 0; i < extraWidth; i++) {
              entry.values[1][extraStart0 + i] = newExtra[i];
            }
            entry.fetchedAt = Date.now();
          }

          // Patch local rows array for this request execution.
          for (let i = 0; i < extraWidth; i++) {
            row2[extraStart0 + i] = newExtra[i];
          }
        }
      }
    } catch (e) {
      Logger.log('[parseSetSheet_] Legacy cleanup skipped: ' + e.message);
    }
  }

  // Convert DATA_START_ROW from 1-based sheet row to 0-based array index
  const dataStartIdx = dataStartRow ? dataStartRow - 1 : null;
  
  const finalRows = (allRowsUpdated !== null && allRowsUpdated !== undefined) ? allRowsUpdated : allRows;
  
  // After auto-provision, userSettingsCol was set but we need to use the updated data
  // Extract user settings (2 columns) - from USER_SETTINGS_START_ROW up to (but not including) header row
  Logger.log('[parseSetSheet_] Extraction params: userSettingsCol=' + userSettingsCol + ', headerIdx=' + headerIdx + ', USER_SETTINGS_START_ROW=' + USER_SETTINGS_START_ROW);
  const userSettings = (userSettingsCol !== null && headerIdx !== null) 
    ? finalRows.slice(USER_SETTINGS_START_ROW - 1, headerIdx).map(row => {
        const slice = row.slice(userSettingsCol, userSettingsCol + USER_SETTINGS_WIDTH);
        while (slice.length < USER_SETTINGS_WIDTH) slice.push("");
        return slice;
      })
    : [];
  
  Logger.log('[parseSetSheet_] Extracted ' + userSettings.length + ' user settings rows');
  if (userSettings.length > 0) {
    Logger.log('[parseSetSheet_] First setting: ' + JSON.stringify(userSettings[0]));
    Logger.log('[parseSetSheet_] All settings: ' + JSON.stringify(userSettings));
  }

  const userProgress = (userProgressCol !== null && userAreaWidth && dataStartIdx !== null) 
    ? finalRows.slice(dataStartIdx).map(row => {
        const slice = row.slice(userProgressCol, userProgressCol + userAreaWidth);
        while (slice.length < userAreaWidth) slice.push("");
        return slice;
      })
    : [];
  
  Logger.log('[parseSetSheet_] Extracted ' + userProgress.length + ' user progress rows');
    
  // Extract cards as subarray from DATA_START_ROW to end, columns 0 to STUDY_SET_SCHEMA length
  const dataWidth = Object.keys(STUDY_SET_SCHEMA).length;
  const cards = (dataStartIdx !== null) 
    ? finalRows.slice(dataStartIdx).map(row => row.slice(0, dataWidth))
    : [];
  
  Logger.log('[parseSetSheet_] Extracted ' + cards.length + ' cards');
  
  const result = {
    setSettings,
    userSettings,
    userProgress,
    cards
  };
  
  // Validate that we have user settings if we found user columns
  if (userSettingsCol !== null && userSettings.length === 0) {
    Logger.log('[parseSetSheet_] WARNING: Found user columns but extracted 0 settings rows');
  }
  
  return result;
}

// Purpose: write user settings array to the sheet.
// Inputs: sheetName, userId, userSettings (array of arrays), setSettings (contains DATA_START_ROW).
// Outputs: number of rows written.
function writeUserSettings_(sheetName, userId, userSettings, setSettings) {
  if (!Array.isArray(userSettings) || !userSettings.length) return 0;
  const t0 = Date.now();
  
  const dataStartRow = Number(setSettings?.DATA_START_ROW);
  if (!dataStartRow) return 0;
  
  // Try cached column first
  const cacheKey = `${sheetName}_${userId}`.toLowerCase();
  let userSettingsCol = USER_COL_CACHE[cacheKey];
  
  if (userSettingsCol === undefined) {
    const sh = getSheet_(sheetName);
    // amazonq-ignore-next-line
    const allRows = sh.getRange(1, 1, 2, sh.getLastColumn()).getValues();
    userSettingsCol = findUserSettingsCol_(allRows, userId, sheetName);
    if (userSettingsCol === null) throw new Error(`User columns not found for ${userId} in sheet ${sheetName}`);
  }
  
  // amazonq-ignore-next-line
  const sh = getSheet_(sheetName);
  const sheetCol = userSettingsCol + 1;
  sh.getRange(USER_SETTINGS_START_ROW, sheetCol, userSettings.length, USER_SETTINGS_WIDTH).setValues(userSettings);
  
  // Update cache if it exists
  const sheetData = SHEET_DATA_CACHE[_normalizeSheetCacheKey_(sheetName)];
  if (sheetData) {
    setCachedCells_(sheetData, USER_SETTINGS_START_ROW, sheetCol, userSettings);
  }
  
  Logger.log(`[BACK→SHEET] WRITE settings ${sheetName} ${userSettings.length}×${USER_SETTINGS_WIDTH} ${Date.now()-t0}ms`);
  return userSettings.length;
}

// Purpose: write user progress array to the sheet.
// Inputs: sheetName, userId, userProgress (array of arrays), setSettings (contains USER_AREA_WIDTH and DATA_START_ROW).
// Outputs: number of rows written.
function writeUserProgress_(sheetName, userId, userProgress, setSettings) {
  if (!Array.isArray(userProgress) || !userProgress.length) return 0;
  const t0 = Date.now();
  
  // amazonq-ignore-next-line
  const userAreaWidth = Number(setSettings?.USER_AREA_WIDTH);
  const dataStartRow = Number(setSettings?.DATA_START_ROW);
  if (!userAreaWidth || !dataStartRow) return 0;
  
  // Try cached column first
  const cacheKey = `${sheetName}_${userId}`.toLowerCase();
  let userSettingsCol = USER_COL_CACHE[cacheKey];
  
  if (userSettingsCol === undefined) {
    const sh = getSheet_(sheetName);
    const allRows = sh.getRange(1, 1, 2, sh.getLastColumn()).getValues();
    userSettingsCol = findUserSettingsCol_(allRows, userId, sheetName);
    if (userSettingsCol === null) throw new Error(`User columns not found for ${userId} in sheet ${sheetName}`);
  }

  // In this sheet layout, the user block is a single contiguous progressWidth-wide area.
  // Settings use the first 2 columns in the settings rows; progress uses all columns in data rows.
  // So progress starts at the same block start column.
  const userProgressCol = userSettingsCol;
  const sh = getSheet_(sheetName);
  const sheetCol = userProgressCol + 1;
  sh.getRange(dataStartRow, sheetCol, userProgress.length, userAreaWidth).setValues(userProgress);
  
  // Update cache if it exists
  const sheetData = SHEET_DATA_CACHE[_normalizeSheetCacheKey_(sheetName)];
  if (sheetData) {
    setCachedCells_(sheetData, dataStartRow, sheetCol, userProgress);
  }
  
  Logger.log(`[BACK→SHEET] WRITE progress ${sheetName} ${userProgress.length}×${userAreaWidth} ${Date.now()-t0}ms`);
  return userProgress.length;
}



// Purpose: add a custom menu to the spreadsheet for administrators.
// Inputs: none.
// Outputs: none (side effect).
// Flow: Triggered by the open event; Calls: SpreadsheetApp.getUi().
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu("SRS")
    .addItem("Build/Refresh Distractors", "buildDistractorsCache")
    .addItem("Invalidate Cache", "menuInvalidateCache")
    .addToUi();
}

// amazonq-ignore-next-line
function menuInvalidateCache() {
  clearAllCachesAndQueues_();
  SpreadsheetApp.getActiveSpreadsheet().toast(
    'All caches & queues cleared',
    'Cache Invalidated',
    3
  );
}

function onEdit(e) {
  try {
    if (!e || !e.source) return;
    const sheetName = e.source.getActiveSheet().getName();
    if (sheetName === USERS_SHEET) {
      invalidateSheetCache_(USERS_SHEET);
    }
  } catch (err) {
    // amazonq-ignore-next-line
    Logger.log('[onEdit] ERROR: ' + err.message);
  }
}

// Purpose: helper to obtain the active spreadsheet.
// Inputs: none.
// Outputs: SpreadsheetApp active instance.
// Flow: Called by sh_; Calls: SpreadsheetApp.getActive().
// ==== Config helpers ====
function getSs_(){ return SpreadsheetApp.getActive(); }

// Purpose: fetch a named sheet or throw if missing.
// Inputs: name (string).
// Outputs: Sheet instance.
// Flow: Called by helpers needing sheet data (parseSetSheet_, buildDistractorsCache, etc.); Calls: getSs_.
function sh_(name){ const s=getSs_().getSheetByName(name); if(!s) throw new Error("Missing sheet: "+name); return s; }

// Purpose: compute similarity between two strings for distractors.
// Inputs: s1, s2 (strings to compare).
// Outputs: Jaro-Winkler similarity score (0-1).
// Flow: Called by pickFor; Calls: none.
// ==== Similarity (Jaro-Winkler) for “smart” distractors ====
function jaroWinkler_(s1, s2){
  if (!s1 || !s2) return 0;
  const a = s1.toLowerCase(), b = s2.toLowerCase();
  const m = Math.max(0, Math.floor(Math.max(a.length, b.length) / 2) - 1);
  const matchesA = new Array(a.length).fill(false);
  const matchesB = new Array(b.length).fill(false);
  let matches = 0, transpositions = 0;

  for (let i=0;i<a.length;i++){
    const start = Math.max(0, i-m), end = Math.min(i+m+1, b.length);
    for (let j=start;j<end;j++){
      if (!matchesB[j] && a[i]===b[j]){ matchesA[i]=matchesB[j]=true; matches++; break; }
    }
  }
  if (!matches) return 0;

  let k=0;
  for (let i=0;i<a.length;i++){
    if (matchesA[i]){
      while(!matchesB[k]) k++;
      if (a[i]!==b[k]) transpositions++;
      k++;
    }
  }
  const jaro = (matches/a.length + matches/b.length + (matches - transpositions/2)/matches)/3;
  let l=0; while(l<4 && a[l] && b[l] && a[l]===b[l]) l++;
  return jaro + l*0.1*(1-jaro);
}

// Purpose: rebuild the distractor cache for a sheet.
// Inputs: userId to resolve the caller’s active set.
// Outputs: none (writes values to the sheet).
// Flow: Called from the custom menu and scripts; Calls: resolveActiveSetSheet_, sh_, getSheetData_, parseSetSheet_, pickFor.
function buildDistractorsCache() {
  const sh = SpreadsheetApp.getActiveSpreadsheet().getActiveSheet();
  const sheetName = sh.getName();

  // Check if DistractorsAsReference is enabled
  const sheetData = getSheetData_(sheetName);
  const sheetRows = sheetData.values || [];
  let distractorMode = '';
  // amazonq-ignore-next-line
  for (let i = 1; i < Math.min(sheetRows.length, MAX_SETTINGS_SEARCH_ROWS + 1); i++) {
    const row = sheetRows[i] || [];
    if (String(row[0] || '').trim().toLowerCase() === 'distractorsasreference') {
      distractorMode = String(row[1] || '').trim().toLowerCase();
      break;
    }
  }
  if (distractorMode === 'off' || distractorMode === 'false' || distractorMode === '0') {
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `Skipped cache: DistractorsAsReference is OFF for ${sheetName}`,
      'Distractor Builder',
      5
    );
    return;
  }

  // Get card data from parseSetSheet_
  // amazonq-ignore-next-line
  const parsed = parseSetSheet_(sheetName);
  const data = parsed.cards;
  const dataStartRow = Number(parsed.setSettings.DATA_START_ROW);
  if (!dataStartRow || dataStartRow < 2) {
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `DATA_START_ROW not found or invalid in ${sheetName}`,
      'Distractor Builder',
      5
    );
    return;
  }
  
  if (!data.length) {
    SpreadsheetApp.getActiveSpreadsheet().toast(
      `No cards found in ${sheetName}`,
      'Distractor Builder',
      3
    );
    return;
  }
  
  // amazonq-ignore-next-line
  const N = Object.keys(STUDY_SET_SCHEMA).filter(key => key.startsWith('distractor')).length; // 3 distractors
  const startCol = STUDY_SET_SCHEMA.distractor1; // 0-based column index (column E)

  // rows for pickFor: map cards to their actual sheet row numbers
  const rows = data.map((r, i) => ({
    row: dataStartRow + i,
    term: String(r[STUDY_SET_SCHEMA.term] || '').trim()
  }));
  
  const out = rows.map((src, i) => {
    if (i % 200 === 0) {
      const msg = `Processing row ${dataStartRow + i} / ${rows.length}`;      
      SpreadsheetApp.getActiveSpreadsheet().toast(msg, 'Building Distractors', 5);
    }

    const arr = pickFor(src, rows, N);   // row numbers
    const rowNums = arr.slice(0, N);
    while (rowNums.length < N) rowNums.push('');
    return rowNums;
  });

  sh.getRange(dataStartRow, startCol + 1, out.length, N).setValues(out); // Convert to 1-based for Sheets API
}


// Purpose: pick distractor rows similar to a source term.
// Inputs: x (term record), allRows (pool), numDistractorsOverride (optional count).
// Outputs: array of sheet row numbers for distractors.
// Flow: Called by buildDistractorsCache; Calls: jaroWinkler_.
function pickFor(x, allRows, numDistractorsOverride) {
  const source = String(x?.term || "");
  if (!source) return [];

  // Pool = all other rows with a term
  const pool = (allRows || []).filter(y => {
    const t = String(y?.term || "");
    return t && t.toLowerCase() !== source.toLowerCase();
  });
  if (!pool.length) return [];

  // Use override if provided; otherwise fall back to reading settings (for any other callers)
  const numDistractors = (numDistractorsOverride != null) ? numDistractorsOverride : 3;

  // include row so we can return indices directly
  const srcLen = source.length;
  const scored = pool
    .filter(y => {
      const len = String(y.term || "").length;
      return Math.abs(len - srcLen) <= Math.max(len, srcLen) * 0.6; // keep “roughly similar” lengths
    })
    .map(y => ({ 
      t: y.term, 
      r: y.row,
      s: jaroWinkler_(source, y.term)
    }))
    .sort((a, b) => b.s - a.s);
  
  const out = [];
  const seen = new Set(); // de-dup by term (case-insensitive), same as before
  for (let i = 0; i < scored.length && out.length < numDistractors; i++) {
    const t = String(scored[i].t || "");
    const k = t.toLowerCase();
    if (t && !seen.has(k)) {
      seen.add(k);
      out.push(scored[i].r); // <-- return the sheet row number
    }
  }
  return out; // e.g., [2, 19, 87, ...] (1-based; 2 is first data row)
}


// Purpose: serve JSON API for frontend.
// Inputs: e (event object with postData).
// Outputs: JSON response.
// Flow: Called by fetch() from frontend; routes to appropriate function.
// ==== Web App API ====
function doPost(e) {
  try {
    const raw = e && e.postData && e.postData.contents ? e.postData.contents : '{}';
    const data = JSON.parse(raw);
    const action = String(data.action || '').toLowerCase();
    let result;

    switch (action) {
      case 'getsession':
        result = getSession(data);
        break;
      case 'savesession':
        result = saveSession(data);
        break;
      case 'changepassword':
        result = changePassword(data);
        break;
      default:
        result = { success: false, error: 'Unknown action: ' + (data.action || '') };
    }

    return createJsonResponse_(result);
  } catch (err) {
    Logger.log('[doPost] ERROR: ' + err);
    return createJsonResponse_({
      success: false,
      error: String(err)
    });
  }
}

function createJsonResponse_(obj) {
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

// Purpose: change a user's password. Expects { userId, currentPassword, newPassword }.
// Returns: { success: true } or { success: false, error: '...' }
function changePassword(payload) {
  try {
    // amazonq-ignore-next-line
    if (!payload || !payload.userId || !payload.currentPassword || !payload.newPassword) {
      return { success: false, error: 'MISSING_FIELDS' };
    }
    const email = String(payload.userId).trim().toLowerCase();
    const current = String(payload.currentPassword);
    const nw = String(payload.newPassword);

    // Basic checks
    // amazonq-ignore-next-line
    if (nw.length < 6) return { success: false, error: 'WEAK_PASSWORD' };
    if (current === nw) return { success: false, error: 'SAME_PASSWORD' };

    const sheetData = getSheetData_(USERS_SHEET);
    const allData = sheetData.values || [];
    if (allData.length < 2) return { success: false, error: 'USER_NOT_FOUND' };

    const userIdRow = allData[0] || [];
    const pwdRow = allData[1] || [];

    let foundCol = -1;
    for (let col = 1; col < userIdRow.length; col++) {
      const colEmail = String(userIdRow[col] || '').trim().toLowerCase();
      if (colEmail === email) {
        foundCol = col;
        break;
      }
    }
    if (foundCol === -1) return { success: false, error: 'USER_NOT_FOUND' };

    const existingPwd = String(pwdRow[foundCol] || '');
    if (existingPwd !== current) return { success: false, error: 'WRONG_PASSWORD' };

    // Write new password
    const sh = getSheet_(USERS_SHEET);
    // amazonq-ignore-next-line
    sh.getRange(2, foundCol + 1).setValue(nw);

    // Invalidate caches so subsequent reads see new password
    invalidateSheetCache_(USERS_SHEET);

    // Opportunistically flush login logs
    // amazonq-ignore-next-line
    flushLoginLogQueue_(true);

    return { success: true };
  } catch (e) {
    Logger.log('[changePassword] ERROR: ' + e.message);
    // amazonq-ignore-next-line
    return { success: false, error: e.message };
  }
}

function doGet(e) {
  return ContentService
    .createTextOutput(JSON.stringify({
      error: 'This is a JSON API. Use POST requests with action parameter.'
    }))
    .setMimeType(ContentService.MimeType.JSON);
}

// ==== Exposed Functions for UI (google.script.run) ====

function sanitize2DArray_(arr) {
  if (!Array.isArray(arr)) return [];
  return arr.map(row => {
    if (!Array.isArray(row)) return [];
    return row.map(cell => {
      if (cell === null || cell === undefined) return '';
      if (typeof cell === 'boolean') return cell;
      if (typeof cell === 'number') return cell;
      if (cell instanceof Date) {
        // Return datetime as YYYY-MM-DD HH:MM:SS string without timezone conversion
        const y = cell.getFullYear();
        const m = String(cell.getMonth() + 1).padStart(2, '0');
        const d = String(cell.getDate()).padStart(2, '0');
        const h = String(cell.getHours()).padStart(2, '0');
        const min = String(cell.getMinutes()).padStart(2, '0');
        const s = String(cell.getSeconds()).padStart(2, '0');
        return `${y}-${m}-${d} ${h}:${min}:${s}`;
      }
      return String(cell);
    });
  });
}


// Purpose: gather the session snapshot for a caller, optionally switching to a different set.
// amazonq-ignore-next-line
// Inputs: arg (optional object with userId and/or setName).
// Outputs: session object with message field (empty on success, error message on failure).
// Flow: Exposed via google.script.run; Calls: getCallerId_, resolveActiveSetSheet_, parseSetSheet_, getAvailableSetNames_.
function resolveActiveSet_(arg, availableSets) {
  if (!arg || !arg.setName) return null;
  const requestedSet = String(arg.setName).trim();
  return (requestedSet && availableSets.includes(requestedSet)) ? requestedSet : null;
}

function buildEmptySessionResponse_(userId, availableSets) {
  return {
    success: true,
    userId: userId,
    activeSet: null,
    availableSets: availableSets,
    allSets: getAllSetNames_(),
    adminEmail: ADMIN_EMAIL,
    setSettings: {},
    cards: [],
    userSettings: [],
    userPreferences: extractGlobalSettings_(userId),
    userProgress: [],
    studySetSchema: STUDY_SET_SCHEMA,
    userProgressSchema: USER_PROGRESS_SCHEMA
  };
}

function extractGlobalSettings_(userId) {
  const userCol = readActiveUserConfig_(userId);
  const globalSettings = [];
  // Mirror sheet structure: header row + user row, then values
  globalSettings.push(['Setting', 'Value']);
  globalSettings.push(['UserID', userId]);
  const theme = userCol[USER_SCHEMA.themelight];
  const autoPlay = userCol[USER_SCHEMA.audioautoplay];
  const speed = userCol[USER_SCHEMA.playbackspeed];
  if (theme === undefined || autoPlay === undefined || speed === undefined) {
    throw new Error(`Missing global settings for user ${userId} in Users sheet`);
  }
  globalSettings.push(['ThemeLight', theme]);
  globalSettings.push(['AudioAutoPlay', autoPlay]);
  globalSettings.push(['PlaybackSpeed', speed]);
  return globalSettings;
}

// Purpose: return global settings as an object for convenience.
// Inputs: userId (string)
// Outputs: { ThemeLight, AudioAutoPlay, PlaybackSpeed }
function extractGlobalSettingsObj_(userId) {
  const arr = extractGlobalSettings_(userId);
  const obj = {};
  for (const row of arr) {
    if (!Array.isArray(row) || row.length < 2) continue;
    const key = String(row[0] || '').trim();
    if (!key || key === 'Setting' || key === 'UserID') continue; // skip header/user rows
    obj[key] = row[1];
  }
  return obj;
}

function cleanSessionData_(parsed) {
  const cleanSettings = {};
  for (let k in parsed.setSettings) {
    let v = parsed.setSettings[k];
    // amazonq-ignore-next-line
    if (v instanceof Boolean) v = v.valueOf();
    if (v instanceof Number) v = v.valueOf();
    if (typeof v === "undefined") v = "";
    if (v === null) v = "";
    cleanSettings[k] = v;
  }

  const cleanStudySetSchema = {};
  for (const key in STUDY_SET_SCHEMA) {
    cleanStudySetSchema[key] = Number(STUDY_SET_SCHEMA[key]);
  }

  const cleanUserProgressSchema = {};
  for (const key in USER_PROGRESS_SCHEMA) {
    cleanUserProgressSchema[key] = Number(USER_PROGRESS_SCHEMA[key]);
  }

  return {
    cleanSettings,
    cleanStudySetSchema,
    cleanUserProgressSchema,
    cleanCards: sanitize2DArray_(parsed.cards),
    cleanUserSettings: sanitize2DArray_(parsed.userSettings),
    cleanUserProgress: sanitize2DArray_(parsed.userProgress)
  };
}

function getSession(arg) {
  const t0 = Date.now();
  Logger.log('[PERF_BACK] getSession START');
  let dbg = null;
  try {
    const t1 = Date.now();
    const userId = getCallerId_(arg);
    const isAdmin = String(userId || '').toLowerCase() === String(ADMIN_EMAIL).toLowerCase();
    dbg = makeDebugBuffer_(isAdmin);
    debugLog_(dbg, `[getSession] caller=${userId}`);
    Logger.log(`[PERF_BACK] getCallerId ${Date.now()-t1}ms`);
    if (!userId) {
      return attachDebug_(dbg, { success: false, error: 'Cannot identify caller' });
    }
    const t2 = Date.now();
    const availableSets = getAvailableSetNames_(userId);
    debugLog_(dbg, `[getSession] availableSets=${availableSets.length}`);
    Logger.log(`[PERF_BACK] getAvailableSetNames ${Date.now()-t2}ms`);
    const activeSet = resolveActiveSet_(arg, availableSets);
    if (!activeSet) {
      Logger.log(`[PERF_BACK] getSession TOTAL ${Date.now()-t0}ms (no active set)`);
      return attachDebug_(dbg, buildEmptySessionResponse_(userId, availableSets));
    }
    let parsed;
    try {
      const t3 = Date.now();
      parsed = parseSetSheet_(activeSet, userId);
      debugLog_(dbg, `[getSession] parsed set=${activeSet}`);
      Logger.log(`[PERF_BACK] parseSetSheet ${Date.now()-t3}ms`);
    } catch (e) {
      Logger.log('[getSession] parseSetSheet_ ERROR: ' + e.message);
      let globals = [];
      try { globals = extractGlobalSettings_(userId); } catch (ex) { globals = []; }
      return attachDebug_(dbg, {
        success: false,
        error: e.message,
        userId: userId,
        activeSet: activeSet,
        availableSets: availableSets,
        setSettings: {},
        cards: [],
        userSettings: [],
        userPreferences: globals,
        userProgress: []
      });
    }
    if (!parsed.setSettings.DATA_START_ROW) {
      Logger.log('[getSession] Validation failed: missing metadata');
      return attachDebug_(dbg, { success: false, error: `Sheet "${activeSet}" is missing required metadata: DATA_START_ROW`, availableSets: availableSets });
    }
    const t4 = Date.now();
    const cleaned = cleanSessionData_(parsed);
    Logger.log(`[PERF_BACK] cleanSessionData ${Date.now()-t4}ms`);
    const t4b = Date.now();
    const globalSettings = extractGlobalSettings_(userId);
    Logger.log(`[PERF_BACK] extractGlobalSettings ${Date.now()-t4b}ms`);
    let result = {
      success: true,
      userId: String(userId),
      activeSet: String(activeSet),
      availableSets: availableSets.map(s => String(s)),
      setSettings: cleaned.cleanSettings,
      cards: cleaned.cleanCards,
      userSettings: cleaned.cleanUserSettings,
      userSetSchema: (function() {
        const schema = {};
        for (const k in USER_SET_SCHEMA) {
          schema[k] = { type: USER_SET_SCHEMA[k].type };
        }
        return schema;
      })(),
      userPreferences: globalSettings,
      userProgress: cleaned.cleanUserProgress,
      studySetSchema: cleaned.cleanStudySetSchema,
      userProgressSchema: cleaned.cleanUserProgressSchema
    };
    debugLog_(dbg, `[getSession] cards=${result.cards.length} userSettings=${result.userSettings.length} userPreferences=${result.userPreferences.length}`);
    const t5 = Date.now();
    let size = 0;
    try {
      const testJson = JSON.stringify(result);
      size = testJson.length;
      Logger.log(`[PERF_BACK] JSON.stringify ${Date.now()-t5}ms`);
    } catch (e) {
      Logger.log('[getSession] JSON serialization FAILED: ' + e.message);
      return attachDebug_(dbg, { success: false, error: 'Serialization error: ' + e.message });
    }
    Logger.log(`[PERF_BACK] getSession TOTAL ${Date.now()-t0}ms`);
    Logger.log(`[BACK_TO_FRONT] getSession ${(size/1024).toFixed(1)}KB ${Date.now()-t0}ms`);
    return attachDebug_(dbg, result);
  } catch (e) {
    Logger.log('[getSession] EXCEPTION: ' + e.message);
    Logger.log('[getSession] Stack: ' + e.stack);
    if (e.message === 'USER_NOT_FOUND' || e.message === 'WRONG_PASSWORD') {
      return attachDebug_(dbg, { success: false, error: e.message });
    }
    return attachDebug_(dbg, { success: false, error: `Error in getSession: ${e.message || String(e)}` });
  }
}

// Purpose: persist client-side changes (settings or progress).
// Inputs: payload (object with userSettings and/or userProgress arrays).
// Outputs: result object with message field (empty on success, error message on failure).
// Flow: Exposed via google.script.run; Calls: getCallerId_, resolveActiveSetSheet_, writeUserSettings_, writeUserProgress_.
// Helper function to save test results to TestResults sheet
function saveTestResult_(userId, testDateTime, setName, questionsAnswered, percentage, testSessionId) {
  const t0 = Date.now();
  try {
    const SHEET_NAME = 'TestResults';
    // amazonq-ignore-next-line
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    let sheet = ss.getSheetByName(SHEET_NAME);
    
    if (!sheet) {
      sheet = ss.insertSheet(SHEET_NAME);
      sheet.getRange(1, 1, 1, 6).setValues([['UserID', 'TestDateTime', 'SetName', 'QuestionsAnswered', 'Percentage', 'SessionID']]);
      APPEND_SHEET_CACHE[SHEET_NAME] = 1;
    }
    
    let targetRow = null;
    if (testSessionId) {
      // Use find/search more efficiently: only check the SessionID column (F)
      const lastRow = sheet.getLastRow();
      if (lastRow > 1) {
        const sessionIdRange = sheet.getRange(2, 6, lastRow - 1, 1).getValues();
        for (let i = 0; i < sessionIdRange.length; i++) {
          if (sessionIdRange[i][0] === testSessionId) {
            targetRow = i + 2;
            // Verify userId matches before updating
            const userIdCell = sheet.getRange(targetRow, 1).getValue();
            if (userIdCell !== userId) {
              targetRow = null; // mismatch, treat as new row
            }
            break;
          }
        }
      }
    }
    
    if (targetRow) {
      // amazonq-ignore-next-line
      sheet.getRange(targetRow, 1, 1, 6).setValues([[userId, testDateTime, setName, questionsAnswered, percentage, testSessionId]]);
      Logger.log(`[BACK→SHEET] UPDATE TestResults row ${targetRow} ${Date.now()-t0}ms`);
    } else {
      let nextRow = APPEND_SHEET_CACHE[SHEET_NAME];
      if (!nextRow) {
        nextRow = sheet.getLastRow();
        APPEND_SHEET_CACHE[SHEET_NAME] = nextRow;
      }
      nextRow++;
      sheet.getRange(nextRow, 1, 1, 6).setValues([[userId, testDateTime, setName, questionsAnswered, percentage, testSessionId]]);
      APPEND_SHEET_CACHE[SHEET_NAME] = nextRow;
      Logger.log(`[BACK→SHEET] APPEND TestResults row ${nextRow} ${Date.now()-t0}ms`);
    }
    
    return true;
  } catch (e) {
    Logger.log('saveTestResult_ error: ' + e.message);
    return false;
  }
}

function getSheetMetadata_(sheetName) {
  let metadata = SHEET_METADATA_CACHE[sheetName];
  if (metadata) return metadata;
  
  const t3 = Date.now();
  const key = _normalizeSheetCacheKey_(sheetName);
  
  try {
    const cache = CacheService.getScriptCache();
    const cached = cache.get('header_' + key);
    if (cached) {
      const headerCache = JSON.parse(cached);
      metadata = { DATA_START_ROW: headerCache.DATA_START_ROW, USER_AREA_WIDTH: Object.keys(USER_PROGRESS_SCHEMA).length };
      SHEET_METADATA_CACHE[sheetName] = metadata;
      Logger.log(`[SHEET→BACK] READ ${sheetName} metadata CACHED ${Date.now()-t3}ms`);
      return metadata;
    }
  } catch (e) {
    Logger.log('[getSheetMetadata_] Cache read failed: ' + e.message);
  }
  
  const sheetData = getSheetData_(sheetName);
  const headerRow = findHeaderRow_(sheetData);
  // amazonq-ignore-next-line
  const DATA_START_ROW = headerRow ? headerRow + 1 : null;
  
  Logger.log(`[SHEET→BACK] READ ${sheetName} metadata (auto-detected DATA_START_ROW=${DATA_START_ROW}) ${Date.now()-t3}ms`);
  
  metadata = { DATA_START_ROW, USER_AREA_WIDTH: Object.keys(USER_PROGRESS_SCHEMA).length };
  SHEET_METADATA_CACHE[sheetName] = metadata;
  return metadata;
}

function validateSavePayload_(payload, metadata, saveType) {
  const USER_AREA_WIDTH = Object.keys(USER_PROGRESS_SCHEMA).length;
  if (saveType === 'settings' || saveType === 'deckSettings') {
    const deckSettings = Array.isArray(payload.deckSettings)
      ? payload.deckSettings
      : (Array.isArray(payload.data) ? payload.data : []);
    // Enforce full settings-matrix length (prevents overwriting header/progress rows due to malformed payloads).
    const dsr = Number(metadata?.DATA_START_ROW);
    if (dsr) {
      // Settings rows are from USER_SETTINGS_START_ROW (row 2) up to the row before the "Term" header row.
      // Term header row is (DATA_START_ROW - 1). So count = (DATA_START_ROW - 1) - USER_SETTINGS_START_ROW.
      const expectedSettingsRows = Math.max(0, (dsr - 1) - USER_SETTINGS_START_ROW);
      if (deckSettings.length !== expectedSettingsRows) {
        return { valid: false, error: `userSettings row count mismatch: expected ${expectedSettingsRows}, got ${deckSettings.length}` };
      }
    }
    for (let i = 0; i < deckSettings.length; i++) {
      if (!Array.isArray(deckSettings[i]) || deckSettings[i].length !== USER_SETTINGS_WIDTH) {
        return { valid: false, error: `userSettings row ${i} column count mismatch: expected ${USER_SETTINGS_WIDTH}, got ${deckSettings[i]?.length}` };
      }
    }
  } else if (saveType === 'progress') {
    if (metadata.userProgressLength && payload.data.length !== metadata.userProgressLength) {
      return { valid: false, error: `userProgress row count mismatch: expected ${metadata.userProgressLength}, got ${payload.data.length}` };
    }
    for (let i = 0; i < payload.data.length; i++) {
      if (!Array.isArray(payload.data[i]) || payload.data[i].length !== USER_AREA_WIDTH) {
        return { valid: false, error: `userProgress row ${i} column count mismatch: expected ${USER_AREA_WIDTH}, got ${payload.data[i]?.length}` };
      }

      // Guardrail: progress rows must never look like settings rows.
      // If these strings appear, it means the frontend (or a buggy slice) is sending the settings matrix as progress.
      const first = String(payload.data[i][0] ?? '').trim().toLowerCase();
      if (first === 'setting' || first === 'userid') {
        return { valid: false, error: `progress payload looks like settings data (row ${i} col0="${payload.data[i][0]}")` };
      }
    }
  }
  return { valid: true };
}

function validateDeckSettings_(deckSettings, metadata) {
  const dsr = Number(metadata?.DATA_START_ROW);
  if (dsr) {
    // Settings rows are from USER_SETTINGS_START_ROW (row 2) up to the row before the "Term" header row.
    // Term header row is (DATA_START_ROW - 1). So count = (DATA_START_ROW - 1) - USER_SETTINGS_START_ROW.
    const expectedSettingsRows = Math.max(0, (dsr - 1) - USER_SETTINGS_START_ROW);
    if (deckSettings.length !== expectedSettingsRows) {
      return { valid: false, error: `userSettings row count mismatch: expected ${expectedSettingsRows}, got ${deckSettings.length}` };
    }
  }
  for (let i = 0; i < deckSettings.length; i++) {
    if (!Array.isArray(deckSettings[i]) || deckSettings[i].length !== USER_SETTINGS_WIDTH) {
      return { valid: false, error: `userSettings row ${i} column count mismatch: expected ${USER_SETTINGS_WIDTH}, got ${deckSettings[i]?.length}` };
    }
  }
  return { valid: true };
}

function validateUserProgress_(userProgress, metadata) {
  const USER_AREA_WIDTH = Object.keys(USER_PROGRESS_SCHEMA).length;
  if (metadata?.userProgressLength && userProgress.length !== metadata.userProgressLength) {
    return { valid: false, error: `userProgress row count mismatch: expected ${metadata.userProgressLength}, got ${userProgress.length}` };
  }
  for (let i = 0; i < userProgress.length; i++) {
    if (!Array.isArray(userProgress[i]) || userProgress[i].length !== USER_AREA_WIDTH) {
      return { valid: false, error: `userProgress row ${i} column count mismatch: expected ${USER_AREA_WIDTH}, got ${userProgress[i]?.length}` };
    }
    const first = String(userProgress[i][0] ?? '').trim().toLowerCase();
    if (first === 'setting' || first === 'userid') {
      return { valid: false, error: `progress payload looks like settings data (row ${i} col0="${userProgress[i][0]}")` };
    }
  }
  return { valid: true };
}

function writeGlobalSettings_(userId, globalSettings) {
  const t0 = Date.now();
  const sheetData = getSheetData_(USERS_SHEET);
  const allData = sheetData.values || [];
  const userIdRow = allData[0] || [];
  const targetUserId = String(userId).trim().toLowerCase();
  
  let userCol = -1;
  for (let col = 1; col < userIdRow.length; col++) {
    if (String(userIdRow[col] || '').trim().toLowerCase() === targetUserId) {
      userCol = col;
      break;
    }
  }
  
  if (userCol === -1) throw new Error('User not found in Users sheet');
  
  const sh = getSheet_(USERS_SHEET);
  const updates = [];
  for (const [name, value] of globalSettings) {
    if (name === 'ThemeLight') updates.push([USER_SCHEMA.themelight + 1, value]);
    else if (name === 'AudioAutoPlay') updates.push([USER_SCHEMA.audioautoplay + 1, value]);
    else if (name === 'PlaybackSpeed') updates.push([USER_SCHEMA.playbackspeed + 1, value]);
  }
  
  if (updates.length > 0) {
    for (const [row, value] of updates) {
      sh.getRange(row, userCol + 1).setValue(value);
    }
    invalidateSheetCache_(USERS_SHEET);
  }
  
  Logger.log(`[BACK→SHEET] WRITE Users(global settings) ${updates.length} cells ${Date.now()-t0}ms`);
  return updates.length;
}

function saveSession(payload) {
  const t0 = Date.now();
  Logger.log('[FRONT_BACK] saveSession START');
  let dbg = null;
  try {
    if (!payload || typeof payload !== 'object') {
      // amazonq-ignore-next-line
      return attachDebug_(dbg, { success: false, error: 'Invalid payload' });
    }

    // Unified save payload (no backwards compatibility required):
    // { userId, password, activeSet, deckSettings?, userProgress?, userSettings? }
    // - deckSettings: 2-col KV matrix written into the per-user block on the set sheet
    // - userProgress: 6-col matrix written under the header row on the set sheet
    // - userSettings: global settings (ThemeLight/AudioAutoPlay/PlaybackSpeed) written to Users sheet
    // Also supports legacy-aux features by presence:
    // - feedbackData
    // - testData

    const saveType = String(payload.saveType || '').trim();
    if (payload.feedbackData) {
      const { userId, currentSet, message } = payload.feedbackData;
      saveFeedback_(userId || 'anonymous', currentSet || '', message);
      return attachDebug_(dbg, { success: true, wroteFeedback: true });
    }

    const t1 = Date.now();
    const callerId = getCallerId_(payload);
    const isAdmin = String(callerId || '').toLowerCase() === String(ADMIN_EMAIL).toLowerCase();
    dbg = makeDebugBuffer_(isAdmin);
    debugLog_(dbg, `[saveSession] unified caller=${callerId} legacySaveType=${saveType || ''}`);
    if (!callerId) {
      return attachDebug_(dbg, { success: false, error: 'Cannot identify caller' });
    }
    const userId = callerId;
    Logger.log(`[BACK] getCallerId ${Date.now()-t1}ms`);
    const result = { success: true, userId };
    let actionsTaken = 0;

    if (payload.testData) {
      const { testDateTime, setName, questionsAnswered, percentage, testSessionId } = payload.testData;
      result.wroteTestResult = saveTestResult_(userId, testDateTime, setName, questionsAnswered, percentage, testSessionId);
      actionsTaken++;
    }

    // Unified main saves (optional sections)
    const hasDeckSettings = Array.isArray(payload.deckSettings) && payload.deckSettings.length > 0;
    const hasUserProgress = Array.isArray(payload.userProgress) && payload.userProgress.length > 0;
    const hasUserSettings = Array.isArray(payload.userSettings) && payload.userSettings.length > 0;

    if (hasDeckSettings || hasUserProgress) {
      const sheetName = String(payload.activeSet || '').trim();
      if (!sheetName) return attachDebug_(dbg, { success: false, error: 'activeSet is required for set saves' });
      const metadata = getSheetMetadata_(sheetName);
      if (!metadata.DATA_START_ROW) return attachDebug_(dbg, { success: false, error: `Sheet "${sheetName}" is missing required metadata` });

      if (hasDeckSettings) {
        let deckSettings = normalizeUserSetSettings_(payload.deckSettings, userId);
        debugLog_(dbg, `[saveSession] deckSettings=${deckSettings.length}`);
        const validation = validateDeckSettings_(deckSettings, metadata);
        if (!validation.valid) return attachDebug_(dbg, { success: false, error: validation.error });
        result.wroteUserSettings = writeUserSettings_(sheetName, userId, deckSettings, metadata);
        result.activeSet = sheetName;
        actionsTaken++;
      }

      if (hasUserProgress) {
        const validation = validateUserProgress_(payload.userProgress, metadata);
        if (!validation.valid) return attachDebug_(dbg, { success: false, error: validation.error });
        result.wroteUserProgress = writeUserProgress_(sheetName, userId, payload.userProgress, metadata);
        result.activeSet = sheetName;
        actionsTaken++;
      }
    }

    if (hasUserSettings) {
      let globalSettings = payload.userSettings
        .filter(r => Array.isArray(r) && r.length >= 2)
        .map(r => [r[0], r[1]]);
      globalSettings = globalSettings.filter(r => {
        const name = String(r[0] || '');
        if (!name || name === 'Setting' || name === 'Settings' || name === 'UserID' || name === 'Password') return false;
        return GLOBAL_SETTINGS.includes(name);
      });
      debugLog_(dbg, `[saveSession] userSettings(global)=${globalSettings.length}`);
      if (globalSettings.length > 0) {
        result.wroteGlobalSettings = writeGlobalSettings_(userId, globalSettings);
        actionsTaken++;
      }
    }

    if (actionsTaken === 0) {
      return attachDebug_(dbg, { success: false, error: 'No data to save (invalid saveType or missing data)' });
    }
    // amazonq-ignore-next-line
    flushLoginLogQueue_(true);
    Logger.log(`[BACK_TO_FRONT] saveSession(unified) ${Date.now()-t0}ms`);
    return attachDebug_(dbg, result);
  } catch (e) {
    return attachDebug_(dbg, { success: false, error: `Error in saveSession: ${e.message || String(e)}` });
  }
}
