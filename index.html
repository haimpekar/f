<!-- 2025-12-06 ‚Äî Sheet Quiz UI (standalone-friendly) -->
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>Sheet Quiz UI</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />

    <style>
        /* Reset + full height */
        html,
        body {
            height: 100%;
        }

        /* 2025-11-07 18:05 IDT ‚Äî Make body a flex column: header on top, main area fills the rest */
        body {
            margin: 0;
            padding: 0;
            background: #fafafa;
            font-family: system-ui, Arial, sans-serif;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
            overflow: hidden;
        }

        body[data-theme="dark"] {
            background: #111;
            color: #f3f3f3;
        }

        body[data-theme="dark"] .card,
        body[data-theme="dark"] .answers {
            background: #1c1c1f;
            color: #fdfdfd;
        }

        body[data-theme="dark"] .statusbar {
            color: #f3f3f3;
        }

        body[data-theme="dark"] .answer {
            background: #2a2a2f;
            border-color: #3a3a3f;
            color: #fdfdfd;
        }

        body[data-theme="dark"] .answer:hover {
            background: #3a3a42;
            border-color: #5a5a63;
        }

        body[data-theme="dark"] .answer.correct {
            border-color: #3c8e3c;
            background: #224122;
            color: #f7fff7;
        }

        body[data-theme="dark"] .answer.incorrect {
            border-color: #d13939;
            background: #2f1a1a;
            color: #ffecec;
        }

        /* header / config row: natural height, no flex */
        #configRow,
        .statusbar {
            flex: 0 0 auto;
        }

        /* main quiz/done areas share the remaining height */
        #quizArea,
        #doneArea {
            flex: 1 1 auto;
        }

        /* Card container */
        .card {
            box-sizing: border-box;
            margin: 0;
            width: 100%;
            max-width: clamp(720px, 90vw, 1100px);
            height: min(100svh, 900px);
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 12px;
            background: #fff;
            border: none;
        }

        .row {
            margin: 0;
        }

        .muted {
            color: #666;
        }

        /* MAIN area */
        /* 2025-11-07 18:05 IDT ‚Äî Done screen: center message in the reserved main area */
        #doneArea {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            box-sizing: border-box;
            padding: 16px 12px 24px;
            text-align: center;
        }

        #doneArea h3 {
            margin: 0 0 8px;
            font-size: 1.6rem;
        }

        #doneArea .row {
            margin-top: 4px;
        }

        /* 2025-10-31 14:58 IDT ‚Äî Shared MCQ sizing */
        :root {
            /* One knob for main MCQ typography (term + options) */
            --mcq-font-size: clamp(22px, 2.6vw, 38px);
        }

        /* Unified status/progress area at top ("1/4 ‚Ä¢ Demo MCQ") */
        .statusbar {
            position: relative;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            flex-wrap: wrap;
            padding: 4px max(12px, calc((100vw - min(96%, 1100px)) / 2));
            min-height: 28px;
            color: #444;
            font-size: clamp(11px, 1.4vw, 18px);
            gap: 4px;
        }

        #statusBarText {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            font-size: clamp(16px, 2vw, 24px);
            font-weight: 500;
            text-align: center;
            max-width: 90%;
            direction: ltr;
            unicode-bidi: embed;
        }

        #quizArea,
        #doneArea {
            flex: 1 1 auto;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #termImageWrap {
            margin: 8px auto 12px auto;
            width: 100%;
            max-width: clamp(320px, 60vw, 540px);
            max-height: 25vh;
            border-radius: 14px;
            overflow: hidden;
            display: none;
        }

        #termImageWrap.active {
            display: block;
        }

        #termImageWrap img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        .status-stats {
            font-size: clamp(12px, 1vw, 14px);
            margin-left: 12px;
            color: #555;
        }

        /* term line: centered and same size as options */
        .term {
            font-weight: 800;
            line-height: 1.25;
            margin-top: 4px;
            font-size: var(--mcq-font-size);
            text-align: center;
            color: #000;
        }

        #termText {
            font-size: clamp(16px, 2.2vw, 34px);
            line-height: 1.15;
            overflow: hidden;
            word-break: break-word;
            hyphens: auto;
        }

        #termText[dir="auto"] {
            text-align: start;
        }

        .answer {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;

            padding: 12px 16px;
            border-radius: 10px;
            border: none;
            cursor: pointer;

            min-height: 72px;
            /* base card height */
            width: 100%;

            white-space: normal;
            /* allow multi-line text */
            word-break: break-word;
            /* break long words instead of overflowing */

            font-size: clamp(0.95rem, 0.9rem + 0.2vw, 1.1rem);
            line-height: 1.3;
        }

        .answers.is-flash {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 14px;
        }

        @media (min-width: 1024px) {
            .answers {
                grid-auto-rows: minmax(140px, 1fr);
            }
        }

        /* On phones / narrow portrait: prefer 2 columns (2√ó2, 2√ó3) */
        @media (max-width: 720px) and (orientation: portrait) {

            .answers[data-count="4"],
            .answers[data-count="6"],
            .answers:not([data-count]) {
                grid-template-columns: repeat(2, minmax(0, 1fr));
                gap: 18px;
            }
        }

        /* Ultra-narrow (very small phones) ‚Üí single column fallback */
        @media (max-width: 360px) {

            .answers[data-count],
            .answers:not([data-count]) {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 900px) and (orientation: portrait) {
            .answers[data-count="6"] {
                grid-template-columns: repeat(2, minmax(0, 1fr));
            }
        }

        button.answer {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 8px;
            min-height: 0;
            border-radius: 16px;
            border: 1px solid #dcdcdc;
            background: #f5f5f5;
            color: #111;
            font-size: var(--mcq-font-size);
            line-height: 1.2;
            cursor: pointer;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            transition: transform 100ms ease, background 100ms ease, border-color 100ms ease;
            overflow: hidden;
        }

        body[data-theme="dark"] button.answer {
            background: #2a2a2f;
            border-color: #444;
            color: #f5f5f5;
        }

        body[data-theme="dark"] .answer-label {
            color: #f5f5f5;
        }

        @media (hover:hover) {
            button.answer:hover {
                background: #f3f3f3;
                border-color: #cfcfcf;
            }
        }

        button.answer:active {
            transform: scale(0.997);
        }

        @media (max-width: 720px) {
            .answers:not([data-count]) {
                grid-template-columns: 1fr;
                gap: 18px;
            }
        }

        #termHeader {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            max-width: 1080px;
            margin: 0 auto 8px auto;
            padding: 0 4px;
            max-height: 20vh;
            overflow: hidden;
        }

        @media (max-width: 640px) {
            #termHeader {
                padding: 0 2px;
                max-height: 15vh;
            }
        }

        .audio-btn {
            border: 1px solid #ccc;
            background: #f7f7f7;
            border-radius: 999px;
            padding: 4px 8px;
            line-height: 1;
            cursor: pointer;
            font-size: 14px;
        }

        .audio-btn.audio-only-mode {
            font-size: clamp(80px, 15vw, 180px);
            padding: 40px;
            border: 3px solid #1976d2;
            background: #e3f2fd;
            box-shadow: 0 8px 24px rgba(25, 118, 210, 0.3);
        }

        body[data-theme="dark"] .audio-btn.audio-only-mode {
            background: #1a3a52;
            border-color: #42a5f5;
        }

        .audio-btn:active {
            transform: scale(0.98);
        }

        .audio-btn[disabled] {
            opacity: .5;
            cursor: default;
        }

        button.answer.correct {
            border-color: #1f7a1f;
            outline: 2px solid #1f7a1f;
            background: #f1fff1;
        }

        button.answer.incorrect {
            border-color: #a11;
            outline: 2px solid #a11;
            background: #fff1f1;
        }

        button.answer:disabled {
            opacity: 0.95;
            pointer-events: none;
        }

        #termText {
            margin: 0;
            /* center in page */
            padding: 0;
            /* tiny side breathing */
        }

        /* Inner label for answers */
        .answer-label {
            display: -webkit-box;
            -webkit-box-orient: vertical;
            width: 100%;
            padding: 0;
            white-space: normal;
            unicode-bidi: embed;
            overflow-wrap: break-word;
            word-break: break-word;
            hyphens: auto;
            line-height: 1.15;
            overflow: hidden;
        }

        /* Feedback */
        .feedback {
            min-height: 2.2em;
            font-size: clamp(18px, 1.8vw, 26px);
            line-height: 1.35;
            font-weight: 500;
            text-align: center;
        }

        .success {
            color: #1f7a1f;
        }

        .error {
            color: #a11;
        }

        /* Controls row */
        .controls {
            display: flex;
            gap: 10px;
            justify-content: space-between;
            min-height: 44px;
        }

        .hidden {
            display: none;
        }

        /* 2025-10-31 14:58 IDT ‚Äî Desktop-only: allow selecting/copying status + options text */
        @media (pointer: fine) {
            .statusbar {
                user-select: text;
                -webkit-user-select: text;
            }

            .answer-label {
                user-select: text;
                -webkit-user-select: text;
            }
        }

        .flip-face {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 18px;
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            text-align: center;
            font-size: var(--mcq-font-size);
            line-height: 1.25;
        }

        .flip-front,
        .flip-back {
            background: #fff;
            color: #000;
        }

        .flip-back {
            transform: rotateY(180deg);
        }

        body[data-theme="dark"] .flip-front,
        body[data-theme="dark"] .flip-back {
            background: #2a2a2f;
            color: #fff;
        }

        .fc-btn.correct {
            border-color: #1f7a1f;
            background: #f1fff1;
        }

        .fc-btn.wrong {
            border-color: #a11;
            background: #fff1f1;
        }

        @media (pointer: fine) {
            .flip-face {
                user-select: text;
                -webkit-user-select: text;
            }
        }

        body[data-busy="1"] * {
            cursor: progress !important;
        }

        .settings-wrap {
            max-width: 90%;
            margin: 10px auto 14px auto;
            padding: 16px;
            border: 1px dashed #ddd;
            border-radius: 12px;
            background: #fafafa;
            font-size: 16px;
        }

        @media (max-width: 640px) {
            .settings-wrap {
                max-width: 95%;
                padding: 20px;
                font-size: 18px;
            }
        }

        body[data-theme="dark"] .settings-wrap {
            background: #2a2a2f;
            border-color: #3a3a3f;
        }

        .settings-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }

        .settings-head h3 {
            margin: 0;
            font-size: 16px;
            font-weight: 600
        }

        .settings-head .meta {
            font-size: 12px;
            color: #666;
            font-weight: normal;
        }

        .settings-grid {
            display: grid;
            grid-template-columns: auto 1fr;
            gap: 12px 16px;
            align-items: center;
        }

        .settings-grid .label {
            align-self: center;
            font-size: 16px;
        }

        .settings-grid .control {
            align-self: center;
            justify-self: start;
        }

        @media (max-width: 640px) {
            .settings-grid {
                gap: 16px 20px;
            }

            .settings-grid .label {
                font-size: 18px;
            }
        }

        .settings-grid select,
        .settings-grid input {
            width: 150px;
            box-sizing: border-box;
            font-size: 16px;
            padding: 8px;
        }

        @media (max-width: 640px) {

            .settings-grid select,
            .settings-grid input {
                width: 180px;
                font-size: 18px;
                padding: 12px;
                min-height: 44px;
            }
        }

        .settings-grid [data-readonly="1"] {
            opacity: 0.85;
        }

        .modal[hidden] {
            display: none;
        }

        .modal {
            position: fixed;
            inset: 0;
            z-index: 50;
        }

        .modal-backdrop {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.25);
        }

        .modal-card {
            position: relative;
            margin: 8vh auto 0 auto;
            width: fit-content;
            background: #fff;
            border-radius: 14px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
            padding: 14px;
        }

        body[data-theme="dark"] .modal-card {
            background: #1c1c1f;
            color: #f3f3f3;
        }

        .modal-head {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .modal-close {
            border: 1px solid #ccc;
            background: #f7f7f7;
            border-radius: 8px;
            padding: 6px 10px;
            cursor: pointer;
        }

        .statusbar .status-right {
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .statusbar #menuBtn {
            border: 1px solid #ccc;
            background: #f7f7f7;
            border-radius: 8px;
            padding: 8px 12px;
            line-height: 1.2;
            cursor: pointer;
            font-size: 18px;
            margin-right: 8px;
            min-height: 44px;
            min-width: 44px;
        }

        @media (max-width: 640px) {
            .statusbar #menuBtn {
                font-size: 22px;
                padding: 12px 16px;
            }
        }

        .menu-dropdown {
            position: fixed;
            top: 40px;
            left: max(12px, calc((100vw - min(96%, 1100px)) / 2));
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 12px;
            z-index: 1000;
            min-width: 180px;
            font-size: 16px;
        }

        @media (max-width: 640px) {
            .menu-dropdown {
                min-width: 240px;
                font-size: 18px;
                padding: 16px;
            }
        }

        .menu-dropdown[hidden] {
            display: none !important;
        }

        .menu-item {
            display: block;
            align-items: center;
            justify-content: space-between;
            padding: 8px 0;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            text-align: left;
        }

        .menu-item:last-child {
            border-bottom: none;
        }

        .menu-item:hover {
            background: #f5f5f5;
        }

        .menu-label {
            font-size: 16px;
        }

        .menu-item label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 4px;
        }

        .menu-item select {
            width: 100%;
            padding: 6px 8px;
            border-radius: 6px;
            border: 1px solid #ccc;
            background: #f7f7f7;
        }

        .menu-item button {
            width: 100%;
            border: 1px solid #ccc;
            background: #f7f7f7;
            border-radius: 6px;
            padding: 8px 12px;
            cursor: pointer;
            text-align: left;
        }

        @media (max-width: 640px) {
            .menu-label {
                font-size: 18px;
            }
        }

        .menu-arrow {
            font-size: 12px;
            color: #999;
        }

        .menu-icon {
            font-size: 14px;
        }

        .submenu {
            position: fixed;
            top: 40px;
            left: calc(max(12px, calc((100vw - min(96%, 1100px)) / 2)) + 200px);
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            padding: 8px 0;
            z-index: 1001;
            min-width: 150px;
        }

        .submenu-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 16px;
            cursor: pointer;
            font-size: 14px;
        }

        .submenu-item:hover {
            background: #f5f5f5;
        }

        .submenu-item.active {
            font-weight: 600;
        }

        .submenu-check {
            font-size: 12px;
            color: #1976d2;
        }

        body[data-theme="dark"] .menu-dropdown,
        body[data-theme="dark"] .submenu {
            background: #2a2a2f;
            border-color: #444;
        }

        body[data-theme="dark"] .menu-item:hover,
        body[data-theme="dark"] .submenu-item:hover {
            background: #3a3a3f;
        }

        .settings-footer {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 10px;
        }

        .btn {
            border: 1px solid #ccc;
            background: #f7f7f7;
            border-radius: 8px;
            padding: 6px 12px;
            cursor: pointer;
        }

        .btn.primary {
            background: #1a73e8;
            border-color: #1a73e8;
            color: #fff;
        }

        .btn[disabled] {
            opacity: 0.6;
            cursor: default;
        }

        /* [2025-11-04 23:16 IDT] Feedback + answer states */
        #feedback {
            margin-top: 8px;
            min-height: 3.5em;
            max-height: 3.5em;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .answer.wrong {
            background-color: #f44336;
            color: #fff;
            position: relative;
        }

        .answer.selected-wrong {
            background: #ffe6e6;
            border-color: #d32f2f;
            color: #111;
            position: relative;
        }

        body[data-theme="dark"] .answer.selected-wrong {
            background: #4a1a1a;
            border-color: #d32f2f;
            color: #fff;
        }

        .answer.selected-wrong::after {
            content: "‚úó";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 4.5em;
            color: #d32f2f;
            pointer-events: none;
            line-height: 1;
        }

        /* 2025-11-07 17:10 IDT ‚Äî MCQ layout: use same ‚Äúcard‚Äù space as flash and split into grid cells */
        #termHeader[data-hide="1"] {
            display: none;
        }

        /* Base container for answers (MCQ + flash) */
        .answers {
            margin: 0 auto;
            max-width: clamp(720px, 90vw, 1100px);
            padding: 0 12px;
            flex: 1 1 auto;
            overflow: hidden;
        }

        /* MCQ mode: big card area like flashcard, split into equal-height rows */
        .answers:not(.is-flash) {
            display: grid;
            gap: 12px;
            width: min(96%, 1100px);
            max-height: min(74svh, 680px);
            grid-auto-rows: minmax(0, 1fr);
            align-items: stretch;
            align-content: stretch;
        }

        /* Default (fallback) ‚Äî 2 columns */
        .answers:not(.is-flash):not([data-count]) {
            grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        /* 4 options ‚Üí 2√ó2 */
        .answers:not(.is-flash)[data-count="4"] {
            grid-template-columns: repeat(2, minmax(0, 1fr));
        }

        /* 6 options ‚Üí 3√ó2 on wide screens (overridden to 2√ó3 on portrait/narrow below) */
        .answers:not(.is-flash)[data-count="6"] {
            grid-template-columns: repeat(3, minmax(0, 1fr));
        }

        /* FlashCard layout: keep using its own full-size flex layout */
        .answers.is-flash {
            display: flex;
            flex-direction: column;
            align-items: center;
            /* center horizontally */
            justify-content: flex-start;
            width: 100%;
            max-width: clamp(720px, 90vw, 1100px);
            margin: 0 auto;
            padding: 8px 12px 12px;
            gap: 16px;
        }


        .flash-wrap {
            width: 100%;
            height: 100%;
            display: grid;
            place-items: center;
        }

        .flip-card {
            width: min(96%, 1100px);
            max-height: min(74svh, 680px);
            height: 100%;
            perspective: 1200px;
        }

        .flip-inner {
            position: relative;
            width: 100%;
            height: 100%;
            transform-style: preserve-3d;
            transition: transform 500ms cubic-bezier(.25, .8, .25, 1);
            border-radius: 18px;
            border: 1px solid #ddd;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .08);
        }

        body[data-theme="dark"] .flip-inner {
            border-color: #444;
        }

        .flip-card.is-flipped .flip-inner {
            transform: rotateY(180deg);
        }

        .flip-face {
            position: absolute;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: clamp(16px, 3vw, 32px);
            backface-visibility: hidden;
            -webkit-backface-visibility: hidden;
            text-align: center;
            font-size: clamp(28px, 4.5vw, 64px);
            line-height: 1.25;
            border-radius: 18px;
            overflow: hidden;
            word-break: break-word;
        }

        .flip-front {
            background: #fff;
        }

        .flip-back {
            background: #fff;
            transform: rotateY(180deg);
        }

        .flash-controls {
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 14px;
            padding-bottom: 8px;
            margin: 0 auto;
        }

        /* hard-hide any controls that are not ready (or have [hidden]) */
        .flash-controls[hidden],
        .flash-controls[data-ready="0"] {
            display: none !important;
        }

        .fc-btn {
            display: grid;
            place-items: center;
            min-height: 60px;
            min-width: clamp(140px, 22vw, 220px);
            /* keep two nice big buttons */
            font-size: clamp(18px, 2vw, 22px);
            border-radius: 14px;
            border: 1px solid #dcdcdc;
            background: #f7f7f7;
            cursor: pointer;
            user-select: none;
            transition: transform 120ms ease, box-shadow 120ms ease, background 120ms ease, border-color 120ms ease;
        }

        .fc-btn:active {
            transform: scale(0.98);
        }

        .fc-btn.disabled {
            opacity: .85;
            cursor: default;
        }

        .fc-btn.picked {
            box-shadow: 0 0 0 3px rgba(0, 0, 0, .05) inset;
            transform: scale(0.995);
        }

        /* Subtle hint for which was correct (only applied to OK when wrong was picked) */
        .fc-btn.hint {
            outline: 2px dashed #1f7a1f;
            outline-offset: 3px;
        }

        /* Card-level feedback glow */
        .flip-card.flash-correct .flip-inner {
            box-shadow: 0 0 0 3px #1f7a1f, 0 12px 28px rgba(31, 122, 31, .15);
            border-radius: 18px;
        }

        .flip-card.flash-incorrect .flip-inner {
            box-shadow: 0 0 0 3px #a11, 0 12px 28px rgba(170, 17, 17, .15);
            border-radius: 18px;
        }

        .flip-card {
            cursor: pointer;
        }

        .flip-inner {
            transition: transform 500ms cubic-bezier(.25, .8, .25, 1), box-shadow 200ms;
        }

        .flip-card:hover .flip-inner {
            box-shadow: 0 14px 36px rgba(0, 0, 0, .12);
        }

        .fc-btn.correct {
            border-color: #1f7a1f;
            background: #f1fff1;
        }

        .fc-btn.wrong {
            border-color: #a11;
            background: #fff1f1;
        }

        .hidden {
            display: none !important;
        }

        @media (max-width: 640px) {

            /* flashcard */
            .flip-card {
                width: min(96%, 1100px);
            }

            /* MCQ grid */
            .answers:not(.is-flash) {
                width: min(98%, 1100px);
                gap: 12px;
                padding: 0 4px;
            }

            /* term header line */
            #termHeader {
                padding: 0 8px;
            }

            button.answer {
                padding: 4px;
                line-height: 1.1;
            }

            .answer-label {
                line-height: 1.1;
            }
        }
    </style>

</head>

<body>

    <div id="configRow" class="row muted hidden"></div>
    <div class="statusbar" aria-live="polite">
        <button id="menuBtn" type="button" title="Menu">‚ò∞</button>
        <span id="statusBarText">Loading‚Ä¶</span>
    </div>

    <div id="menuDropdown" class="menu-dropdown" hidden>
        <div class="menu-item" id="studySetMenuItem">
            <span class="menu-label">Study Set</span>
            <span class="menu-arrow">‚ñ∂</span>
        </div>
        <div class="menu-item" id="testModeMenuItem">
            <span class="menu-label" id="testModeLabel">Test Mode</span>
            <span class="menu-icon" id="testModeIcon">üß™</span>
        </div>
        <div class="menu-item" id="suspendMenuItem">
            <span class="menu-label">Suspend</span>
            <span class="menu-arrow">‚ñ∂</span>
        </div>
        <div class="menu-item" id="settingsMenuItem">
            <span class="menu-label">Settings</span>
            <span class="menu-arrow">‚ñ∂</span>
        </div>
        <div class="menu-item" id="feedbackMenuItem">
            <span class="menu-label">Send Feedback</span>
            <span class="menu-icon">üí¨</span>
        </div>
        <div class="menu-item" id="changePasswordMenuItem">
            <span class="menu-label">Change Password</span>
            <span class="menu-icon">üîê</span>
        </div>
        <div class="menu-item" id="logoutMenuItem">
            <span class="menu-label">Logout <span id="userIdDisplay"
                    style="font-size: 0.85em; color: #666;"></span></span>
            <span class="menu-icon">üö™</span>
        </div>
    </div>

    <div id="studySetSubmenu" class="submenu" hidden>
        <div id="studySetList"></div>
    </div>

    <div id="suspendSubmenu" class="submenu" hidden>
        <div id="suspendBandList"></div>
    </div>

    <div id="settingsOptionsSubmenu" class="submenu" hidden>
        <div id="setSettingsOption" class="submenu-item">
            <span>Set Settings</span>
            <span class="menu-icon" aria-hidden="true">‚öôÔ∏è</span>
        </div>
        <div id="userPreferencesOption" class="submenu-item">
            <span>User Preferences</span>
            <span class="menu-icon" aria-hidden="true">üë§</span>
        </div>
    </div>



    <div id="loginModal" class="modal" hidden>
        <div class="modal-backdrop" aria-hidden="true"></div>
        <div class="modal-card">
            <div class="settings-wrap">
                <div class="settings-head">
                    <h3>Sign In</h3>
                </div>
                <div class="settings-grid">
                    <div class="label">Email:</div>
                    <div class="control"><input id="loginEmail" type="email" placeholder="your@email.com"
                            style="width: 200px;"></div>
                    <div class="label">Password:</div>
                    <div class="control">
                        <div style="display:flex;align-items:center;gap:6px;">
                            <input id="loginPassword" type="password" placeholder="password" style="width: 200px;">
                            <button id="loginPwToggle" type="button" class="pw-toggle" aria-pressed="false"
                                aria-label="Show password"
                                style="background:none;border:0;font-size:16px;cursor:pointer;">üëÅÔ∏è</button>
                        </div>
                    </div>
                </div>
                <div class="settings-footer">
                    <button id="loginBtn" class="btn primary" type="button">Sign In</button>
                </div>
                <div id="loginError" class="error" style="margin-top: 10px; display: none;"></div>
            </div>
        </div>
    </div>

    <div id="changePasswordModal" class="modal" hidden>
        <div class="modal-backdrop" aria-hidden="true"></div>
        <div class="modal-card">
            <div class="settings-wrap">
                <div class="settings-head">
                    <h3>Change Password</h3>
                </div>
                <div class="settings-grid">
                    <div class="label">Current password</div>
                    <div class="control">
                        <div style="display:flex;align-items:center;gap:6px;">
                            <input id="cpCurrent" type="password" placeholder="Current password" style="width:200px;">
                            <button id="cpCurrentToggle" type="button" class="pw-toggle" aria-pressed="false"
                                aria-label="Show current password"
                                style="background:none;border:0;font-size:16px;cursor:pointer;">üëÅÔ∏è</button>
                        </div>
                    </div>
                    <div class="label">New password</div>
                    <div class="control">
                        <div style="display:flex;align-items:center;gap:6px;">
                            <input id="cpNew" type="password" placeholder="New password" style="width:200px;">
                            <button id="cpNewToggle" type="button" class="pw-toggle" aria-pressed="false"
                                aria-label="Show new password"
                                style="background:none;border:0;font-size:16px;cursor:pointer;">üëÅÔ∏è</button>
                        </div>
                    </div>
                    <div class="label">Confirm new</div>
                    <div class="control">
                        <div style="display:flex;align-items:center;gap:6px;">
                            <input id="cpConfirm" type="password" placeholder="Confirm new password"
                                style="width:200px;">
                            <button id="cpConfirmToggle" type="button" class="pw-toggle" aria-pressed="false"
                                aria-label="Show confirm password"
                                style="background:none;border:0;font-size:16px;cursor:pointer;">üëÅÔ∏è</button>
                        </div>
                    </div>
                </div>
                <div id="cpError" class="error" style="margin-top:10px; display:none;"></div>
                <div class="settings-footer">
                    <button id="changePasswordCancelBtn" class="btn" type="button">Cancel</button>
                    <button id="changePasswordSaveBtn" class="btn primary" type="button">Save</button>
                </div>
            </div>
        </div>
    </div>

    <div id="settingsModal" class="modal" hidden>
        <div class="modal-backdrop" id="settingsBackdrop" aria-hidden="true"></div>
        <div class="modal-card">
            <div class="settings-wrap" id="settingsWrap">
                <div class="settings-head">
                    <h3>Session Settings</h3>
                    <span id="settingsHint" class="meta"></span>
                </div>
                <div class="settings-grid" id="settingsGrid"></div>
                <div class="settings-footer">
                    <button id="settingsCancelBtn" class="btn" type="button">Cancel</button>
                    <button id="settingsSaveBtn" class="btn primary" type="button">Save</button>
                </div>
            </div>
        </div>
    </div>

    <div id="feedbackModal" class="modal" hidden>
        <div class="modal-backdrop" aria-hidden="true"></div>
        <div class="modal-card" style="width: 500px; max-width: 90vw;">
            <div class="settings-wrap">
                <div class="settings-head">
                    <h3>Send Feedback</h3>
                </div>
                <div style="margin: 10px 0;">
                    <textarea id="feedbackText"
                        placeholder="Share your feedback, report issues, or request access to study sets..."
                        style="width: 100%; min-height: 150px; padding: 8px; border: 1px solid #ccc; border-radius: 6px; font-family: inherit; font-size: 14px; resize: vertical;"></textarea>
                    <div style="text-align: right; font-size: 12px; color: #666; margin-top: 4px;">
                        <span id="feedbackCharCount">0</span> / 1000
                    </div>
                </div>
                <div class="settings-footer">
                    <button id="feedbackCancelBtn" class="btn" type="button">Cancel</button>
                    <button id="feedbackSendBtn" class="btn primary" type="button">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div id="suspendModal" class="modal" hidden>
        <div class="modal-backdrop" aria-hidden="true"></div>
        <div class="modal-card" style="width: 600px; max-width: 90vw;">
            <div class="settings-wrap">
                <div class="settings-head">
                    <h3 id="suspendModalTitle">Suspend Cards</h3>
                </div>
                <div style="margin: 10px 0;">
                    <input id="suspendSearch" type="text" placeholder="Search cards..."
                        style="width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 6px; font-size: 14px; margin-bottom: 10px;">
                    <div id="suspendCardList"
                        style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 6px; padding: 8px;">
                        <!-- Cards will be populated here -->
                    </div>
                </div>
                <div class="settings-footer">
                    <button id="suspendCancelBtn" class="btn" type="button">Cancel</button>
                    <button id="suspendSaveBtn" class="btn primary" type="button">Save Changes</button>
                </div>
            </div>
        </div>
    </div>

    <div id="confirmModal" class="modal" hidden>
        <div class="modal-backdrop" aria-hidden="true"></div>
        <div class="modal-card" style="width: 400px; max-width: 90vw;">
            <div class="settings-wrap">
                <div class="settings-head">
                    <h3 id="confirmTitle">Confirm</h3>
                </div>
                <div style="margin: 10px 0; font-size: 16px;" id="confirmMessage"></div>
                <div class="settings-footer">
                    <button id="confirmCancelBtn" class="btn" type="button">Cancel</button>
                    <button id="confirmOkBtn" class="btn primary" type="button">OK</button>
                </div>
            </div>
        </div>
    </div>

    <div id="quizArea">
        <div id="termHeader">
            <h1 id="termText" class="autoshrink" dir="auto"></h1>
            <button id="audioBtn" class="audio-btn" hidden aria-label="Play term audio" title="Play audio">üîä</button>
            <button id="suspendBtn" class="audio-btn" hidden aria-label="Suspend this card"
                title="Suspend card">üö´</button>
        </div>
        <div id="termImageWrap" class="term-image">
            <img id="termImage" alt="Term related visual" />
        </div>

        <div id="answers" class="answers"></div>
        <div id="feedback" class="row feedback muted"></div>
    </div>

    <div id="doneArea" class="hidden">
        <h3>Done!</h3>
        <p class="row">Score: <span id="scoreText"></span></p>
        <p class="row muted">Saved to <b>Results</b>.</p>
        <div id="extraNewPrompt" class="row" style="display:flex; flex-direction:column; gap:6px; align-items:center;">
            <span class="muted">Want to learn 5 more new items?</span>
            <button id="extraNewBtn" class="btn primary" type="button">Study 5 more new items</button>
        </div>
    </div>


    <script>
        // Audio element and initialization (outside DOMContentLoaded)
        let _audioEl = null;

        function initAudioElement() {
            if (!_audioEl) {
                _audioEl = document.createElement('audio');
                _audioEl.id = 'audio';
                _audioEl.style.display = 'none';
                if (document.body) {
                    document.body.appendChild(_audioEl);
                    log_('[Audio] Element created and appended to body');
                } else {
                    console.warn('[Audio] Body not ready, will append later');
                }
            }
            return _audioEl;
        }

        function $(id) { return document.getElementById(id); }
        function showToast(msg, type = 'info') {
            const toast = document.createElement('div');
            toast.textContent = msg;
            toast.style.cssText = `position:fixed;bottom:20px;left:50%;transform:translateX(-50%);padding:12px 24px;border-radius:8px;font-size:14px;z-index:9999;${type === 'error' ? 'background:#d32f2f;color:#fff' : 'background:#333;color:#fff'}`;
            document.body.appendChild(toast);
            setTimeout(() => toast.remove(), 2000);
        }
        function showError_(msg) {
            const sb = $('statusBarText'), fb = $('feedback');
            if (sb) sb.textContent = `Error: ${String(msg || 'Unknown error')}`;
            if (fb) fb.innerHTML = `<span class="error">${sb ? sb.textContent : msg}</span>`;
            log_(msg);
        }

        function maskSensitiveFields(obj) {
            if (!obj || typeof obj !== 'object') return obj;
            const clone = Array.isArray(obj) ? [...obj] : { ...obj };
            ['password', 'currentPassword', 'newPassword'].forEach((field) => {
                if (Object.prototype.hasOwnProperty.call(clone, field) && clone[field]) {
                    clone[field] = '‚Ä¢‚Ä¢‚Ä¢';
                }
            });
            return clone;
        }

        function summarizeResult(result) {
            if (!result || typeof result !== 'object') return result;
            const summary = {};
            ['success', 'error', 'userId', 'activeSet', 'availableSets', 'adminEmail'].forEach(key => {
                if (Object.prototype.hasOwnProperty.call(result, key)) {
                    summary[key] = result[key];
                }
            });
            if (Array.isArray(result.cards)) summary.cards = `cards[${result.cards.length}]`;
            if (Array.isArray(result.userSettings)) summary.userSettings = `settings[${result.userSettings.length}]`;
            if (Array.isArray(result.userProgress)) summary.userProgress = `progress[${result.userProgress.length}]`;
            if (Array.isArray(result.availableSets)) summary.availableSets = `availableSets[${result.availableSets.length}]`;
            return summary;
        }

        function showConfirm(message, onConfirm) {
            const modal = $('confirmModal');
            const messageEl = $('confirmMessage');
            const okBtn = $('confirmOkBtn');
            const cancelBtn = $('confirmCancelBtn');

            if (!modal || !messageEl || !okBtn || !cancelBtn) return;

            messageEl.textContent = message;
            modal.hidden = false;

            const cleanup = () => {
                modal.hidden = true;
                okBtn.onclick = null;
                cancelBtn.onclick = null;
            };

            okBtn.onclick = () => {
                cleanup();
                if (onConfirm) onConfirm();
            };

            cancelBtn.onclick = cleanup;
        }

        // Make menu-like divs keyboard focusable and activate on Enter/Space
        function makeMenuItemFocusable(el) {
            if (!el) return;
            if (el.tabIndex !== 0) el.tabIndex = 0;
            if (!el.getAttribute('role')) el.setAttribute('role', 'menuitem');
            if (el.dataset && el.dataset.keyboardMenu === '1') return;
            el.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    el.click();
                }
            });
            if (el.dataset) el.dataset.keyboardMenu = '1';
        }

        // Match code.gs.js structure
        const STUDY_SET_SCHEMA = {
            term: 0,
            image: 1,
            band: 2,
            definition: 3,
            distractor1: 4,
            distractor2: 5,
            distractor3: 6
        };
        const USER_PROGRESS_SCHEMA = {
            due: 0,
            step: 1,
            reps: 2,
            lapses: 3,
            suspended: 4,
            tags: 5
        };

        // Global default Ladder (hardcoded for now)
        // Deck (per-set) Ladder may be empty; in that case, we fall back to this.
        const DEFAULT_LADDER_STR = '{1/1440;3/1440;10/1440;30/1440;12/24;2;4;7;14;30;60;90;105;115;120}';

        const MOCK_ITEMS = [
            ['◊î◊ê◊ù ◊ê◊ï◊ò◊ï◊ë◊ï◊° ◊î◊†◊ï◊°◊¢ ◊ë◊†◊™◊ô◊ë ◊©◊ô◊ï◊¢◊ì ◊ú◊™◊ó◊ë◊ï◊®◊î ◊¶◊ô◊ë◊ï◊®◊ô◊™ ◊®◊©◊ê◊ô ◊ú◊¢◊ß◊ï◊£ ◊®◊õ◊ë ◊¢◊ï◊ß◊£?', '', '◊ó◊ï◊ß◊ô ◊î◊™◊†◊ï◊¢◊î', '◊®◊©◊ê◊ô.', '◊®◊©◊ê◊ô, ◊®◊ß ◊ë◊ì◊®◊ö ◊©◊ê◊ô◊†◊î ◊¢◊ô◊®◊ï◊†◊ô◊™.', '◊®◊©◊ê◊ô, ◊®◊ß ◊õ◊ê◊©◊® ◊î◊®◊õ◊ë ◊î◊¢◊ï◊ß◊£ ◊î◊ï◊ê ◊®◊õ◊ë ◊û◊©◊ê.', '◊®◊©◊ê◊ô, ◊ê◊ù ◊ë◊ê◊ï◊ò◊ï◊ë◊ï◊° ◊ê◊ô◊ü ◊†◊ï◊°◊¢◊ô◊ù.'],
            ['◊î◊ê◊ù ◊û◊ï◊™◊® ◊ú◊†◊î◊ï◊í ◊ë◊®◊õ◊ë ◊õ◊ë◊ì ◊õ◊ê◊©◊® ◊ú◊ó◊• ◊î◊ê◊ï◊ï◊ô◊® ◊ë◊û◊¢◊®◊õ◊™ ◊î◊ë◊ú◊ô◊û◊î ◊†◊û◊ï◊ö ◊û◊ü ◊î◊û◊ô◊†◊ô◊û◊ï◊ù ◊î◊†◊ì◊®◊©?', '', '◊ó◊ï◊ß◊ô ◊î◊™◊†◊ï◊¢◊î', '◊ê◊°◊ï◊®.', '◊û◊ï◊™◊®, ◊ê◊ë◊ú ◊®◊ß ◊ë◊ê◊ô◊©◊ï◊® ◊©◊ï◊ò◊® ◊ê◊ï ◊ß◊¶◊ô◊ü.', '◊û◊ï◊™◊®, ◊ê◊ë◊ú ◊®◊ß ◊ê◊ù ◊ô◊õ◊ï◊ú◊™ ◊î◊¢◊¶◊ô◊®◊î ◊©◊ú ◊î◊®◊õ◊ë ◊ò◊ï◊ë◊î.', '◊û◊ï◊™◊®, ◊ê◊ù ◊ë◊®◊ï◊® ◊ú◊ó◊ú◊ï◊ò◊ô◊ü ◊©◊ê◊ô◊ü ◊ì◊ú◊ô◊§◊î.'],
            ['◊û◊î ◊§◊ô◊®◊ï◊© ◊î◊™◊û◊®◊ï◊®?', 'https://www.gov.il/BlobFolder/generalpage/tq_pic_01/he/TQ_PIC_31073.jpg', '◊ó◊ï◊ß◊ô ◊î◊™◊†◊ï◊¢◊î', '◊û◊°◊§◊®◊î ◊©◊ú ◊ì◊®◊ö ◊®◊ê◊©◊ô◊™.', '◊î◊û◊®◊ó◊ß ◊¢◊ì ◊î◊õ◊ë◊ô◊© ◊î◊ß◊®◊ï◊ë (◊ë◊ß"◊û).', '◊û◊°◊§◊®◊î ◊©◊ú ◊ì◊®◊ö ◊û◊î◊ô◊®◊î.', '◊î◊û◊®◊ó◊ß ◊¢◊ì ◊ú◊¶◊ï◊û◊™ ◊î◊ß◊®◊ï◊ë (◊ë◊ß"◊û).'],
            ['◊î◊ô◊õ◊ü ◊™◊¢◊¶◊ï◊® ◊õ◊©◊ë◊¶◊ï◊û◊™ ◊©◊ú◊§◊†◊ô◊ö ◊ì◊ï◊ú◊ß ◊ë◊®◊û◊ñ◊ï◊® ◊î◊ê◊ï◊® ◊î◊ê◊ì◊ï◊ù?', 'https://www.gov.il/BlobFolder/generalpage/tq_pic_01/he/TQ_PIC_3190.jpg', '◊™◊û◊®◊ï◊®◊ô◊ù', '◊ú◊§◊†◊ô ◊ß◊ï ◊î◊¢◊¶◊ô◊®◊î, ◊ï◊ë◊ê◊ô◊ü ◊ß◊ï ◊¢◊¶◊ô◊®◊î - ◊¢◊¶◊ï◊® ◊ú◊§◊†◊ô ◊û◊¢◊ë◊® ◊î◊ó◊¶◊ô◊ô◊î.', '◊ê◊ó◊®◊ô ◊ß◊ï ◊î◊¢◊¶◊ô◊®◊î, ◊ï◊ë◊ê◊ô◊ü ◊ß◊ï ◊¢◊¶◊ô◊®◊î ‚Äì ◊¢◊¶◊ï◊® ◊ú◊§◊†◊ô ◊ß◊ï ◊î◊¶◊ï◊û◊™.', '◊ê◊ó◊®◊ô ◊û◊¢◊ë◊® ◊î◊ó◊¶◊ô◊ô◊î, ◊ï◊ë◊ê◊ô◊ü ◊û◊¢◊ë◊® ◊ó◊¶◊ô◊ô◊î ‚Äì ◊ë◊û◊ß◊ï◊ù ◊©◊ë◊ï ◊©◊ì◊î ◊î◊®◊ê◊ô◊ô◊î ◊î◊ò◊ï◊ë ◊ë◊ô◊ï◊™◊®.', '◊™◊¢◊¶◊ï◊® ◊™◊û◊ô◊ì ◊ë◊û◊ß◊ï◊ù ◊©◊ë◊ï ◊©◊ì◊î ◊î◊®◊ê◊ô◊ô◊î ◊î◊ï◊ê ◊î◊ò◊ï◊ë ◊ë◊ô◊ï◊™◊®.'],
            ['◊ê◊ô◊ñ◊î ◊™◊û◊®◊ï◊® ◊û◊©◊û◊¢◊ï◊™◊ï "◊î◊ï◊ú◊õ◊ô ◊®◊í◊ú ◊ë◊ß◊®◊ë◊™ ◊û◊ß◊ï◊ù"?', 'https://www.gov.il/BlobFolder/generalpage/tq_pic_01/he/TQ_PIC_3368.jpg', '◊™◊û◊®◊ï◊®◊ô◊ù', '136', '135', '226', '306']
        ];

        const MOCK_PROGRESS = [
            ['', 0, 0, 0, 0, ''],
            ['', 0, 0, 0, 0, ''],
            ['', 0, 0, 0, 0, ''],
            ['', 0, 0, 0, 0, ''],
            ['', 0, 0, 0, 0, '']
        ];

        const MOCK_SET_SETTINGS = {
            AudioEnabled: true,
            AudioOnly: false,
            DistractorsAsReference: false,
            Ladder: DEFAULT_LADDER_STR,
            Lang: 'he'
        };

        // Deck-scoped settings (per set) exclude header row to mirror backend payload
        const MOCK_DECK_USER_SETTINGS = [
            ['UserID', 'local@local.com'],
            ['NewItemsPerDay', 4],
            ['QuizMode', false],
            ['TestDueDate', '2025-01-01']
        ];

        // Global user preferences (stored in Users sheet, includes header row like backend)
        const MOCK_USER_PREFERENCES = [
            ['Setting', 'Value'],
            ['UserID', 'local@local.com'],
            ['Password', 'local123'],
            ['ThemeLight', false],
            ['AudioAutoPlay', true],
            ['PlaybackSpeed', 4]
        ];

        function getMockUserId() {
            const row = MOCK_USER_PREFERENCES.find(r => Array.isArray(r) && String(r[0]).toLowerCase() === 'userid');
            return row ? String(row[1] || '').toLowerCase() : null;
        }

        function getMockPassword() {
            const row = MOCK_USER_PREFERENCES.find(r => Array.isArray(r) && String(r[0]).toLowerCase() === 'password');
            return row ? String(row[1] || '') : null;
        }

        let payload = null; // { items, settings, schema, state }
        let settings = []; // active settings for this run (editable)
        let userPreferences = []; // global user preferences (separate from deck settings)
        let settingsViewMode = 'set'; // 'set' or 'user' - controls which settings panel is being edited
        let testState = null; // { activeSet, shuffledIndices, currentIndex, score, startTime, totalQuestions }
        // Debug modes:
        // - 'No'        : no debug output
        // - 'Regular'   : console logging
        // - 'Fireglass' : render logs into the DOM (and also try console)
        // Set this in code (no persistence)
        let DEBUG_MODE = 'Fireglass';

        // Extra noisy, component-specific debug (keep OFF by default)
        const DEBUG_PLAYBACK_SPEED_LOGS = false;

        function setDebugMode(mode) {
            const m = String(mode || '').trim();
            DEBUG_MODE = (m === 'No' || m === 'Regular' || m === 'Fireglass') ? m : 'Regular';
        }

        function formatTs_() {
            try {
                const d = new Date();
                const pad2 = (n) => String(n).padStart(2, '0');
                const pad3 = (n) => String(n).padStart(3, '0');
                return `${pad2(d.getHours())}:${pad2(d.getMinutes())}:${pad2(d.getSeconds())}.${pad3(d.getMilliseconds())}`;
            } catch {
                return '';
            }
        }

        let _consoleTsInstalled = false;
        function installConsoleTimestamps_() {
            try {
                if (_consoleTsInstalled) return;
                if (typeof console !== 'object' || !console) return;
                if (console.__tsWrapped) { _consoleTsInstalled = true; return; }

                const wrap = (methodName) => {
                    const orig = console[methodName];
                    if (typeof orig !== 'function') return;
                    console[methodName] = (...args) => {
                        try {
                            const ts = formatTs_();
                            // Keep it simple: always put timestamp as first arg
                            return orig.call(console, ts, ...args);
                        } catch {
                            try { return orig.call(console, ...args); } catch { /* ignore */ }
                        }
                    };
                };

                ['log', 'info', 'warn', 'error', 'debug'].forEach(wrap);
                console.__tsWrapped = true;
                _consoleTsInstalled = true;
            } catch {
                // ignore
            }
        }

        // Ensure console.* messages also include timestamps
        installConsoleTimestamps_();

        let _debugPane = null;
        let _debugScrollHandlersInstalled = false;
        function debug(msg) {
            // Fireglass-safe: writes to DOM so you can inspect without DevTools.
            try {
                const ts = formatTs_();
                if (!_debugPane) {
                    const pane = document.createElement('div');
                    pane.id = 'debugPane';
                    // Keep visible but NEVER block clicks/taps on the app.
                    // Also keep it behind modals (modals use z-index: 50).
                    pane.style.cssText = 'position:fixed;left:0;right:0;bottom:0;max-height:30vh;overflow:auto;background:rgba(255,255,255,0.92);border-top:1px solid #ddd;padding:6px 8px;z-index:40;font-size:12px;color:#555;pointer-events:none;';
                    // Allow selecting text when we temporarily enable pointer-events.
                    try {
                        pane.style.userSelect = 'text';
                        pane.style.webkitUserSelect = 'text';
                    } catch (e) { /* ignore */ }
                    // In dark theme, keep pane readable
                    try {
                        if (document.body && document.body.dataset && document.body.dataset.theme === 'dark') {
                            pane.style.background = 'rgba(20,20,22,0.92)';
                            pane.style.borderTop = '1px solid #333';
                            pane.style.color = '#bbb';
                        }
                    } catch (e) { /* ignore */ }

                    // Help line (always visible in Fireglass mode)
                    try {
                        const help = document.createElement('div');
                        help.id = 'debugPaneHelp';
                        help.textContent = 'Fireglass: Alt+Wheel scroll ¬∑ Hold Alt to select/copy ¬∑ PageUp/PageDown/Home/End scroll';
                        help.style.cssText = 'font-size:11px;opacity:0.9;white-space:pre-wrap;word-break:break-word;padding:0 0 6px 0;border-bottom:1px solid currentColor;';
                        pane.appendChild(help);
                    } catch (e) { /* ignore */ }

                    _debugPane = pane;
                    const attach = () => {
                        if (!_debugPane || !_debugPane.parentNode) document.body.appendChild(_debugPane);
                    };
                    if (document.body) attach();
                    else window.addEventListener('DOMContentLoaded', attach, { once: true });

                    // Allow scrolling the debug pane without making it intercept clicks:
                    // - Alt + mouse wheel scrolls the pane
                    // - PageUp/PageDown/Home/End scrolls the pane
                    if (!_debugScrollHandlersInstalled) {
                        _debugScrollHandlersInstalled = true;

                        const setSelectMode = (on) => {
                            try {
                                if (!_debugPane) return;
                                // Default is click-through. In select mode, allow interaction so text can be highlighted/copied.
                                _debugPane.style.pointerEvents = on ? 'auto' : 'none';
                                _debugPane.style.cursor = on ? 'text' : 'default';
                                _debugPane.style.outline = on ? '2px dashed currentColor' : 'none';

                                const helpEl = document.getElementById('debugPaneHelp');
                                if (helpEl) {
                                    helpEl.textContent = on
                                        ? 'Fireglass (SELECT MODE): drag to select, Ctrl+C to copy ¬∑ Alt+Wheel scroll'
                                        : 'Fireglass: Alt+Wheel scroll ¬∑ Hold Alt to select/copy ¬∑ PageUp/PageDown/Home/End scroll';
                                }
                            } catch (e) { /* ignore */ }
                        };

                        // Toggle select mode while Alt is held down
                        window.addEventListener('keydown', (e) => {
                            try {
                                if (DEBUG_MODE !== 'Fireglass') return;
                                if (e.key === 'Alt') setSelectMode(true);
                            } catch { /* ignore */ }
                        }, true);
                        window.addEventListener('keyup', (e) => {
                            try {
                                if (DEBUG_MODE !== 'Fireglass') return;
                                if (e.key === 'Alt') setSelectMode(false);
                            } catch { /* ignore */ }
                        }, true);
                        window.addEventListener('blur', () => {
                            try {
                                if (DEBUG_MODE !== 'Fireglass') return;
                                setSelectMode(false);
                            } catch { /* ignore */ }
                        });

                        window.addEventListener('wheel', (e) => {
                            try {
                                if (DEBUG_MODE !== 'Fireglass') return;
                                if (!_debugPane) return;
                                // Only when user explicitly intends to scroll logs
                                if (!e.altKey) return;
                                e.preventDefault();
                                _debugPane.scrollTop += e.deltaY;
                            } catch { /* ignore */ }
                        }, { passive: false });

                        window.addEventListener('keydown', (e) => {
                            try {
                                if (DEBUG_MODE !== 'Fireglass') return;
                                if (!_debugPane) return;
                                const step = Math.max(40, Math.round((_debugPane.clientHeight || 200) * 0.25));
                                if (e.key === 'PageUp') { e.preventDefault(); _debugPane.scrollTop -= step; }
                                else if (e.key === 'PageDown') { e.preventDefault(); _debugPane.scrollTop += step; }
                                else if (e.key === 'Home') { e.preventDefault(); _debugPane.scrollTop = 0; }
                                else if (e.key === 'End') { e.preventDefault(); _debugPane.scrollTop = _debugPane.scrollHeight; }
                            } catch { /* ignore */ }
                        });
                    }
                }
                const el = document.createElement('div');
                el.textContent = ts ? `${ts} ${String(msg)}` : String(msg);
                el.style.cssText = 'font-size:12px;color:inherit;opacity:0.95;white-space:pre-wrap;word-break:break-word;';
                _debugPane.appendChild(el);
                // Keep latest visible
                _debugPane.scrollTop = _debugPane.scrollHeight;
            } catch (e) {
                // last resort: do nothing
            }
        }

        function log_(...args) {
            if (DEBUG_MODE === 'No') return;
            const ts = formatTs_();
            const parts = args.map(a => {
                if (a instanceof Error) return `${a.message}\n${a.stack || ''}`.trim();
                if (typeof a === 'string') return a;
                try { return JSON.stringify(a); } catch (e) { return String(a); }
            });
            const line = parts.join(' ');
            if (DEBUG_MODE === 'Fireglass') {
                debug(`[DEBUG] ${line}`);
                return;
            }
            try { console.log('[DEBUG]', ...args); } catch (e) { /* ignore */ }
        }
        function logBackendDebug(entries, label) {
            if (!Array.isArray(entries) || entries.length === 0) return;
            const title = label ? `[BACKEND DEBUG ${label}]` : '[BACKEND DEBUG]';
            console.groupCollapsed(title);
            entries.forEach(line => log_('[BACK]', line));
            console.groupEnd();
        }

        // Force performance logs to always show (bypass DEBUG_MODE)
        log_('[INIT] Performance logging enabled - you should see timing logs in console');

        // Cloudflare Worker URL (proxies to Apps Script)
        const API_URL = 'https://fsrs.haim-pekar.workers.dev/';

        // Mode selection is based only on credentials.
        // - If a call provides `userId` that matches the mock user, the call uses mock
        // - Else if stored `currentCredentials.email` matches the mock user, use mock
        // - Otherwise the call uses the deployed server implementation
        // This removes any file:// or forceServer heuristics; mode is decided per-call by credentials.
        // user credentials stored under 'userData' includes metadata merged in: activeSet, availableSets, adminEmail
        // userData schema: { email, password (not returned from server), ThemeLight, AudioAutoPlay, PlaybackSpeed, activeSet, availableSets }
        let currentCredentials = null; // { email, password }
        let currentUserMetadata = null; // { activeSet, availableSets, adminEmail } (in-memory contains _ownerEmail for validation)
        try {
            loadCredentials();
            // Migrate legacy metadata (if any) into the single `userData` key
            (function migrateLegacyUserMetadata() {
                try {
                    if (!currentCredentials || !currentCredentials.email) return;
                    const emailKey = String(currentCredentials.email).toLowerCase();
                    const legacyKey = 'userMetadata';
                    const legacyPerUser = `${legacyKey}_${emailKey}`;
                    let migrated = false;
                    const legacy = localStorage.getItem(legacyPerUser) || localStorage.getItem(legacyKey);
                    if (legacy) {
                        try {
                            const parsed = JSON.parse(legacy);
                            if (parsed) {
                                // merge into currentCredentials
                                if (parsed.activeSet) currentCredentials.activeSet = parsed.activeSet;
                                if (Array.isArray(parsed.availableSets)) currentCredentials.availableSets = parsed.availableSets.slice();
                                if (parsed.adminEmail) {
                                    // Do not persist adminEmail to credentials; set it in-memory only
                                    currentUserMetadata = currentUserMetadata || { activeSet: '', availableSets: [], adminEmail: 'administrator' };
                                    currentUserMetadata.adminEmail = parsed.adminEmail;
                                }
                                // Persist using new key 'userData' (ensure defaults)
                                ensureGlobalDefaults(currentCredentials);
                                localStorage.setItem('userData', JSON.stringify(currentCredentials));
                                migrated = true;
                            }
                        } catch (e) {/* ignore parse errors */ }
                    }
                    if (migrated) {
                        try { localStorage.removeItem(legacyPerUser); } catch (e) { }
                        try { localStorage.removeItem(legacyKey); } catch (e) { }
                    }
                } catch (e) { /* swallow */ }
            })();
            loadUserMetadata();
        } catch (e) {
            console.warn('[INIT] loadCredentials() failed during credential-only init', e);
        }
        log_('[INIT] Credential-only mode selection active. Stored email:', currentCredentials && currentCredentials.email ? currentCredentials.email : '<none>');

        function shuffleArray(array) {
            const shuffled = [...array];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            return shuffled;
        }


        // Authentication helpers
        function saveCredentials(email, password, activeSet = null) {
            const creds = { email, password, activeSet };
            // Preserve known global settings if set in memory
            try {
                if (currentCredentials) {
                    if (currentCredentials.ThemeLight !== undefined) creds.ThemeLight = currentCredentials.ThemeLight;
                    if (currentCredentials.AudioAutoPlay !== undefined) creds.AudioAutoPlay = currentCredentials.AudioAutoPlay;
                    if (currentCredentials.PlaybackSpeed !== undefined) creds.PlaybackSpeed = currentCredentials.PlaybackSpeed;
                }
            } catch (e) { /* ignore */ }
            // Merge known metadata into credentials if present
            if (currentUserMetadata) {
                if (currentUserMetadata.activeSet) creds.activeSet = currentUserMetadata.activeSet;
                if (Array.isArray(currentUserMetadata.availableSets)) creds.availableSets = currentUserMetadata.availableSets.slice();
                // adminEmail intentionally not persisted into userData (server is authoritative)
            }
            // Ensure default global settings exist in the saved userData
            ensureGlobalDefaults(creds);
            localStorage.setItem('userData', JSON.stringify(creds));
            currentCredentials = creds;
            if (activeSet) {
                saveUserMetadata({ activeSet });
            }
        }

        function loadCredentials() {
            try {
                // Support migration from old key 'userCredentials' (moved to 'userData')
                let stored = localStorage.getItem('userData');
                if (!stored) stored = localStorage.getItem('userCredentials');
                if (stored) {
                    currentCredentials = JSON.parse(stored);
                    // Ensure default global settings
                    ensureGlobalDefaults(currentCredentials);
                    // If old key found, ensure it's saved under new key and defaults persisted
                    try { localStorage.setItem('userData', JSON.stringify(currentCredentials)); } catch (ignore) { }
                    return currentCredentials;
                }
            } catch (e) {
                log_('Failed to load credentials:', e);
            }
            return null;
        }

        function clearCredentials() {
            localStorage.removeItem('userData');
            // Also remove old key just in case
            try { localStorage.removeItem('userCredentials'); } catch (e) { /* ignore */ }
            currentCredentials = null;
            clearUserMetadataStorage();
        }

        // Note: user metadata is merged into `userData` object in localStorage

        function loadUserMetadata() {
            if (!currentCredentials || !currentCredentials.email) {
                currentUserMetadata = null;
                return null;
            }
            // Use the metadata merged into currentCredentials
            const meta = {
                activeSet: currentCredentials.activeSet || '',
                availableSets: Array.isArray(currentCredentials.availableSets) ? currentCredentials.availableSets.slice() : [],
                adminEmail: (currentUserMetadata && currentUserMetadata.adminEmail) ? currentUserMetadata.adminEmail : 'administrator'
            };
            currentUserMetadata = { ...meta };
            return { ...meta };
        }

        function saveUserMetadata(partial) {
            if (!currentCredentials || !currentCredentials.email) return;
            const existing = loadUserMetadata() || {
                activeSet: currentCredentials.activeSet || '',
                availableSets: [],
                adminEmail: 'administrator'
            };
            const next = {
                activeSet: (partial && partial.activeSet !== undefined)
                    ? partial.activeSet
                    : existing.activeSet,
                availableSets: (partial && Array.isArray(partial.availableSets))
                    ? partial.availableSets.slice()
                    : existing.availableSets
                // adminEmail intentionally not persisted into localStorage
            };
            // Mirror global settings into the credentials if present
            if (partial && partial.ThemeLight !== undefined) next.ThemeLight = partial.ThemeLight;
            if (partial && partial.AudioAutoPlay !== undefined) next.AudioAutoPlay = partial.AudioAutoPlay;
            if (partial && partial.PlaybackSpeed !== undefined) next.PlaybackSpeed = partial.PlaybackSpeed;
            // Save back into currentCredentials for single-key storage
            try {
                currentCredentials.activeSet = next.activeSet;
                currentCredentials.availableSets = Array.isArray(next.availableSets) ? next.availableSets.slice() : [];
                if (next.ThemeLight !== undefined) currentCredentials.ThemeLight = next.ThemeLight;
                if (next.AudioAutoPlay !== undefined) currentCredentials.AudioAutoPlay = next.AudioAutoPlay;
                if (next.PlaybackSpeed !== undefined) currentCredentials.PlaybackSpeed = next.PlaybackSpeed;
                // persist updated credentials object under 'userData' and ensure defaults
                ensureGlobalDefaults(currentCredentials);
                localStorage.setItem('userData', JSON.stringify(currentCredentials));
                // update in-memory metadata only (do not persist adminEmail)
                currentUserMetadata = { activeSet: next.activeSet, availableSets: next.availableSets || [], adminEmail: existing.adminEmail };
            } catch (e) {
                log_('Failed to save user metadata:', e);
            }
        }

        function clearUserMetadataStorage() {
            // Remove metadata fields from the credentials stored under 'userData'
            try {
                if (currentCredentials) {
                    delete currentCredentials.activeSet;
                    delete currentCredentials.availableSets;
                    delete currentCredentials.ThemeLight;
                    delete currentCredentials.AudioAutoPlay;
                    delete currentCredentials.PlaybackSpeed;
                    localStorage.setItem('userData', JSON.stringify(currentCredentials));
                }
            } catch (e) { /* ignore */ }
            currentUserMetadata = null;
        }

        function showLoginModal() {
            const modal = $('loginModal');
            const emailInput = $('loginEmail');
            const passwordInput = $('loginPassword');
            const errorDiv = $('loginError');

            if (modal) modal.hidden = false;
            if (emailInput) {
                emailInput.focus();
                emailInput.value = '';
            }
            if (passwordInput) passwordInput.value = '';
            if (errorDiv) errorDiv.style.display = 'none';
        }

        function hideLoginModal() {
            const modal = $('loginModal');
            if (modal) modal.hidden = true;
        }

        function validateEmail(email) {
            const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            return re.test(email);
        }

        function showLoginError(message) {
            const errorDiv = $('loginError');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                errorDiv.style.color = '#a11';
                errorDiv.style.whiteSpace = 'pre-line'; // Support multi-line messages
            }
        }

        async function attemptLogin(email, password) {
            // Frontend validation
            if (!email || !password) {
                showLoginError('Please fill in all fields');
                return null;
            }

            if (!validateEmail(email)) {
                showLoginError('Please enter a valid email address');
                return null;
            }

            if (email.startsWith("'") || password.startsWith("'")) {
                showLoginError('Email and password cannot start with an apostrophe');
                return null;
            }

            // Show processing message
            const errorDiv = $('loginError');
            if (errorDiv) {
                errorDiv.textContent = 'Processing...';
                errorDiv.style.display = 'block';
                errorDiv.style.color = '#666';
            }

            try {
                const result = await service.getSession({ userId: email, password: password });
                if (result.success !== false) {
                    const prevEmail = currentCredentials && currentCredentials.email
                        ? String(currentCredentials.email).toLowerCase()
                        : null;
                    const nextEmail = String(email).toLowerCase();
                    if (!prevEmail || prevEmail !== nextEmail) {
                        await clearClientStorage();
                    }
                    saveCredentials(email, password);
                    hideLoginModal();
                    return result;
                } else {
                    // Handle specific error messages from backend
                    let errorMsg;
                    if (result.error === 'USER_NOT_FOUND') {
                        errorMsg = 'User not found. Please contact administrator';
                    } else if (result.error === 'WRONG_PASSWORD') {
                        errorMsg = 'Incorrect password. Try again or contact administrator';
                    } else {
                        errorMsg = 'Login failed. Please try again';
                    }
                    showLoginError(errorMsg);
                    return null;
                }
            } catch (e) {
                showLoginError('Connection error. Please try again');
                return null;
            }
        }
        const AUTOSAVE_EVERY = 10;   // save after every 10 answers
        const MIN_REVIEW_INTERVAL_MS = 6 * 60 * 60 * 1000; // allow reviewing items due within 6 hours
        let _lastSavedAnswerCount = 0;
        const DISTRACTOR_KEYS = ['distractor1', 'distractor2', 'distractor3'];

        // Async save queue
        const SaveQueue = {
            queue: [],
            processing: false,

            clear() {
                this.queue = [];
                this.processing = false;
                localStorage.removeItem('saveQueue');
                log_('[SaveQueue] cleared');
            },

            add(saveType, data, options = {}) {
                // Capture credentials NOW to avoid null reference when process() runs later
                const credentials = {
                    userId: currentCredentials?.email,
                    password: currentCredentials?.password,
                    activeSet: payload?.activeSet
                };

                // Validate we have credentials before queueing
                if (!credentials.userId || !credentials.password) {
                    log_('[SaveQueue] Cannot queue save - no credentials');
                    showToast('Not logged in - changes not saved', 'error');
                    return;
                }

                // Deduplicate: remove older saves of same type
                const typeKey = saveType;
                if (saveType === 'progress' || saveType === 'deckSettings' || saveType === 'userPreferences') {
                    const before = this.queue.length;
                    this.queue = this.queue.filter(item => item.typeKey !== typeKey);
                    const removed = before - this.queue.length;
                    if (removed > 0) log_(`[SaveQueue] dedup removed=${removed} type=${typeKey}`);
                }

                const silent = !!(options && options.silent);
                const item = { saveType, typeKey, data, credentials, attempts: 0, timestamp: Date.now(), silent };
                this.queue.push(item);
                localStorage.setItem('saveQueue', JSON.stringify(this.queue));
                log_(`[SaveQueue] queued type=${typeKey} qlen=${this.queue.length}`);
                this.process();
            },

            async process() {
                if (this.processing || this.queue.length === 0) return;
                this.processing = true;

                log_(`[SaveQueue] process start qlen=${this.queue.length}`);

                while (this.queue.length > 0) {
                    const item = this.queue[0];

                    // Use stored credentials from when save was queued
                    const creds = item.credentials || {
                        userId: currentCredentials?.email,
                        password: currentCredentials?.password,
                        activeSet: payload?.activeSet
                    };

                    // Skip if no valid credentials
                    if (!creds.userId || !creds.password) {
                        log_('[SaveQueue] Skipping save - no credentials for:', item.saveType);
                        this.queue.shift();
                        localStorage.setItem('saveQueue', JSON.stringify(this.queue));
                        continue;
                    }

                    try {
                        log_(`[SaveQueue] saving type=${item.typeKey} attempt=${item.attempts + 1} qlen=${this.queue.length}`);
                        await service.saveSession({
                            userId: creds.userId,
                            password: creds.password,
                            activeSet: creds.activeSet,
                            ...item.data
                        });
                        this.queue.shift();
                        localStorage.setItem('saveQueue', JSON.stringify(this.queue));
                        if (!item.silent) showToast(`Saved ${item.saveType}`);
                        log_(`[SaveQueue] saved type=${item.typeKey} remaining=${this.queue.length}`);

                        // Update local IndexedDB cache (DeckCache) so cached session
                        // reflects the newly-saved settings/progress immediately.
                        try {
                            if (typeof DeckCache !== 'undefined') {
                                const activeSetName = payload?.activeSet || creds.activeSet || currentCredentials?.activeSet;
                                const cacheKey = getDeckCacheKey(activeSetName);
                                if (!cacheKey) throw new Error('No active set cache key');
                                const cardWidth = Object.keys(STUDY_SET_SCHEMA).length;
                                const cachedSession = {
                                    cards: Array.isArray(payload?.items) ? payload.items.map(r => Array.isArray(r) ? r.slice(0, cardWidth) : []) : [],
                                    userSettings: Array.isArray(settings) ? stripGlobalSettingsFromArray(settings.map(r => Array.isArray(r) ? r.slice() : [])) : stripGlobalSettingsFromArray(payload?.settings || []),
                                    userProgress: Array.isArray(payload?.items) ? payload.items.map(r => Array.isArray(r) ? r.slice(cardWidth) : []) : [],
                                    setSettings: payload?.setSettings || {}
                                };

                                DeckCache.set(cacheKey, cachedSession).catch(e => log_('[DeckCache] set failed after save:', e));
                            }
                        } catch (e) {
                            log_('Failed to update local cache after save:', e);
                        }
                    } catch (err) {
                        item.attempts++;
                        if (item.attempts >= 3) {
                            log_('[SaveQueue] Failed after 3 attempts:', item.saveType, err);
                            if (!item.silent) showToast(`Failed to save ${item.saveType}`, 'error');
                            this.queue.shift();
                            log_(`[SaveQueue] dropped type=${item.typeKey} remaining=${this.queue.length}`);
                        } else {
                            log_(`[SaveQueue] Retry ${item.attempts}/3 for ${item.saveType}:`, err.message);
                            await new Promise(r => setTimeout(r, 1000 * item.attempts));
                        }
                        localStorage.setItem('saveQueue', JSON.stringify(this.queue));
                    }
                }

                this.processing = false;
                log_('[SaveQueue] process done');
            },

            restore() {
                try {
                    const stored = localStorage.getItem('saveQueue');
                    if (stored) {
                        this.queue = JSON.parse(stored);
                        if (this.queue.length > 0) {
                            log_('[SaveQueue] Restored ' + this.queue.length + ' pending saves');
                            this.process();
                        }
                    }
                } catch (e) {
                    log_('[SaveQueue] Restore failed:', e);
                }
            }
        };

        function buildLexiconSchema(studySetSchema, userProgressSchema) {
            log_('[buildLexiconSchema] Building merged schema');
            const offset = Object.keys(studySetSchema).length;
            const merged = { ...studySetSchema };
            for (const key in userProgressSchema) {
                merged[key] = userProgressSchema[key] + offset;
            }
            log_('[buildLexiconSchema] Merged keys: ' + Object.keys(merged).join(', '));
            return merged;
        }

        // Retry wrapper for transient network errors
        let frontendRetryCount = 0;
        async function retryWithBackoff(fn, maxRetries = 2) {
            for (let attempt = 0; attempt <= maxRetries; attempt++) {
                try {
                    const result = await fn();
                    if (attempt > 0) {
                        frontendRetryCount += attempt;
                        log_(`[retry] Succeeded after ${attempt} retry(ies)`);
                    }
                    return result;
                } catch (err) {
                    if (attempt === maxRetries) {
                        if (attempt > 0) {
                            frontendRetryCount += attempt;
                            log_(`[retry] Failed after ${attempt} retry(ies)`);
                        }
                        throw err;
                    }
                    const delay = 1000 * Math.pow(2, attempt); // 1s, 2s
                    log_(`[retry] Attempt ${attempt + 1}/${maxRetries} failed, waiting ${delay}ms`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // API service: dynamically route calls to mock or real server based on
        // the provided or stored credentials. Decision rules:
        // - If the call provides a `userId` matching the mock user => mock
        // - Else if stored `currentCredentials.email` matches the mock user => mock
        // - Otherwise: server
        const serverImpl = {
            async getSession(arg) {
                const t0 = performance.now();
                log_(`[PERF‚ÜíFRONT] getSession START`);
                const payloadObj = { action: 'getSession', ...arg };
                const sanitized = maskSensitiveFields(payloadObj);
                log_(`[FRONT‚ÜíBACK] getSession payload`, sanitized);
                const payload = JSON.stringify(payloadObj);
                log_(`[PERF‚ÜíFRONT] JSON.stringify ${Math.round(performance.now() - t0)}ms`);
                const t2 = performance.now();
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: payload
                });
                log_(`[PERF‚ÜíFRONT] fetch() ${Math.round(performance.now() - t2)}ms status=${response.status}`);

                const contentType = (response.headers.get('Content-Type') || response.headers.get('content-type') || '').toLowerCase();
                if (!contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('[FRONT‚ÜêBACK] getSession expected JSON but received:', response.status, text);
                    throw new Error('Non-JSON response from server: ' + (String(text).slice(0, 1000)));
                }
                try {
                    const result = await response.json();
                    log_(`[FRONT‚ÜêBACK] getSession response`, summarizeResult(result));
                    const size = JSON.stringify(result).length;
                    log_(`[PERF‚ÜíFRONT] getSession TOTAL ${Math.round(performance.now() - t0)}ms`);
                    log_(`[FRONT‚ÜêBACK] getSession ${(size / 1024).toFixed(1)}KB ${Math.round(performance.now() - t0)}ms`);
                    if (result && Array.isArray(result.debugLog) && result.debugLog.length) logBackendDebug(result.debugLog, 'getSession');
                    if (result === null || result === undefined) throw new Error('Server returned null');
                    return result;
                } catch (err) {
                    const raw = await response.text().catch(() => '');
                    console.error('[FRONT‚ÜêBACK] getSession JSON parse failed:', err.message, 'raw:', raw.slice ? raw.slice(0, 2000) : raw);
                    throw err;
                }
            },

            async saveSession(payload) {
                const t0 = performance.now();
                const sanitized = maskSensitiveFields(payload);
                log_(`[FRONT‚ÜíBACK] saveSession payload`, sanitized);
                const size = JSON.stringify(payload).length;
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'saveSession', ...payload })
                });
                log_(`[PERF‚ÜíFRONT] saveSession fetch() ${Math.round(performance.now() - t0)}ms status=${response.status}`);

                const contentType = (response.headers.get('Content-Type') || response.headers.get('content-type') || '').toLowerCase();
                if (!contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('[FRONT‚ÜêBACK] saveSession expected JSON but received:', response.status, text.slice(0, 2000));
                    throw new Error('Non-JSON response from server: ' + (String(text).slice(0, 1000)));
                }
                try {
                    const result = await response.json();
                    log_(`[FRONT‚ÜêBACK] saveSession response`, summarizeResult(result));
                    const answered = payload?.data ? `answered=${_lastSavedAnswerCount}` : '';
                    log_(`[FRONT‚ÜíBACK] saveSession(${payload.saveType}) ${answered} ${(size / 1024).toFixed(1)}KB ${Math.round(performance.now() - t0)}ms`);
                    if (result && Array.isArray(result.debugLog) && result.debugLog.length) logBackendDebug(result.debugLog, 'saveSession');
                    return result;
                } catch (err) {
                    const raw = await response.text().catch(() => '');
                    console.error('[FRONT‚ÜêBACK] saveSession JSON parse failed:', err.message, 'raw:', raw.slice ? raw.slice(0, 2000) : raw);
                    throw err;
                }
            },

            async changePassword(payload) {
                const t0 = performance.now();
                log_(`[FRONT‚ÜíBACK] changePassword payload`, maskSensitiveFields(payload));
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ action: 'changePassword', ...payload })
                });
                log_(`[PERF‚ÜíFRONT] changePassword fetch() ${Math.round(performance.now() - t0)}ms status=${response.status}`);

                const contentType = (response.headers.get('Content-Type') || response.headers.get('content-type') || '').toLowerCase();
                if (!contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('[FRONT‚ÜêBACK] changePassword expected JSON but received:', response.status, text.slice(0, 2000));
                    throw new Error('Non-JSON response from server: ' + (String(text).slice(0, 1000)));
                }
                try {
                    const result = await response.json();
                    log_(`[FRONT‚ÜêBACK] changePassword response`, summarizeResult(result));
                    log_(`[FRONT‚ÜíBACK] changePassword ${(result && result.success) ? 'OK' : 'FAIL'} ${Math.round(performance.now() - t0)}ms`);
                    return result;
                } catch (err) {
                    const raw = await response.text().catch(() => '');
                    console.error('[FRONT‚ÜêBACK] changePassword JSON parse failed:', err.message, 'raw:', raw.slice ? raw.slice(0, 2000) : raw);
                    throw err;
                }
            }
        };

        const mockImpl = {
            _lastSaved: null,
            async getSession(arg) {
                if (arg && arg.userId && arg.password) {
                    const email = String(arg.userId).toLowerCase();
                    const password = String(arg.password);
                    const mockEmail = getMockUserId();
                    const mockPwd = getMockPassword();
                    if (!mockEmail || email !== mockEmail) return { success: false, error: 'USER_NOT_FOUND' };
                    if (mockPwd !== null && password !== mockPwd) return { success: false, error: 'WRONG_PASSWORD' };
                }
                const cardWidth = Object.keys(STUDY_SET_SCHEMA).length;
                const cards = MOCK_ITEMS;
                const userProgress = MOCK_PROGRESS;
                const userIdRow = MOCK_DECK_USER_SETTINGS.find(r => r[0] === 'UserID');
                if (!userIdRow || !userIdRow[1]) return { success: false, error: 'MOCK_DECK_USER_SETTINGS missing UserID' };
                return {
                    success: true,
                    userId: userIdRow[1],
                    activeSet: 'TestSet',
                    availableSets: ['TestSet'],
                    setSettings: MOCK_SET_SETTINGS,
                    cards: cards,
                    userSettings: MOCK_DECK_USER_SETTINGS,
                    userPreferences: MOCK_USER_PREFERENCES,
                    userProgress: userProgress,
                    studySetSchema: STUDY_SET_SCHEMA,
                    userProgressSchema: USER_PROGRESS_SCHEMA,
                    _isMock: true
                };
            },
            async saveSession(payload) {
                this._lastSaved = payload;
                if (payload?.saveType === 'deckSettings' || payload?.saveType === 'userPreferences' || payload?.saveType === 'settings') {
                    // Prefer new separated fields; fall back to legacy data array
                    let deckSettings = [];
                    let globalSettings = [];

                    if (payload?.saveType === 'deckSettings') {
                        deckSettings = Array.isArray(payload.data) ? payload.data : (Array.isArray(payload.deckSettings) ? payload.deckSettings : []);
                    } else if (payload?.saveType === 'userPreferences') {
                        globalSettings = Array.isArray(payload.data) ? payload.data : (Array.isArray(payload.userPreferences) ? payload.userPreferences : []);
                    } else {
                        deckSettings = Array.isArray(payload.deckSettings) ? payload.deckSettings : [];
                        globalSettings = Array.isArray(payload.userPreferences) ? payload.userPreferences : [];
                    }

                    if ((!deckSettings.length && !globalSettings.length) && Array.isArray(payload.data)) {
                        payload.data.forEach(row => {
                            if (!Array.isArray(row) || row.length < 2) return;
                            const name = String(row[0]);
                            if (name === 'Setting' || name === 'UserID' || name === 'Password') return; // skip header/user rows
                            if (name === 'ThemeLight' || name === 'AudioAutoPlay' || name === 'PlaybackSpeed') {
                                globalSettings.push(row);
                            } else {
                                deckSettings.push(row);
                            }
                        });
                    }

                    // Update mock storage so subsequent mock getSession reflects the changes
                    if (deckSettings.length) {
                        deckSettings.forEach(r => {
                            const name = String(r[0]);
                            const idx = MOCK_DECK_USER_SETTINGS.findIndex(x => Array.isArray(x) && x[0] === name);
                            if (idx >= 0) {
                                MOCK_DECK_USER_SETTINGS[idx][1] = r[1];
                            }
                        });
                    }
                    if (globalSettings.length) {
                        globalSettings.forEach(r => {
                            const name = String(r[0]);
                            const idx = MOCK_USER_PREFERENCES.findIndex(x => Array.isArray(x) && x[0] === name);
                            if (idx >= 0) {
                                MOCK_USER_PREFERENCES[idx][1] = r[1];
                            }
                        });
                    }
                }
                return { success: true };
            },
            async changePassword(arg) {
                if (!arg || !arg.userId || !arg.currentPassword || !arg.newPassword) return { success: false, error: 'MISSING_FIELDS' };
                const email = String(arg.userId).toLowerCase();
                const cur = String(arg.currentPassword);
                const nw = String(arg.newPassword);
                const mockEmail = getMockUserId();
                const mockPwd = getMockPassword();
                if (!mockEmail || email !== mockEmail) return { success: false, error: 'USER_NOT_FOUND' };
                if (mockPwd !== null && mockPwd !== cur) return { success: false, error: 'WRONG_PASSWORD' };
                // Update password row in preferences
                const pwdRow = MOCK_USER_PREFERENCES.find(r => Array.isArray(r) && String(r[0]).toLowerCase() === 'password');
                if (pwdRow) pwdRow[1] = nw;
                return { success: true };
            }
        };

        // Router: choose implementation per-call using provided userId or stored credentials
        function chooseImplForCall(argOrPayload) {
            const email = (argOrPayload && (argOrPayload.userId || argOrPayload.userId === 0))
                ? String(argOrPayload.userId).toLowerCase()
                : (currentCredentials && currentCredentials.email ? String(currentCredentials.email).toLowerCase() : null);
            const mockEmail = getMockUserId();
            const useMock = email && mockEmail && email === mockEmail;
            return useMock ? mockImpl : serverImpl;
        }

        const service = {
            getSession: (arg) => retryWithBackoff(async () => {
                const impl = chooseImplForCall(arg);
                return impl.getSession(arg);
            }),
            saveSession: (payload) => retryWithBackoff(async () => {
                const impl = chooseImplForCall(payload);
                return impl.saveSession(payload);
            }),
            changePassword: (payload) => retryWithBackoff(async () => {
                const impl = chooseImplForCall(payload);
                return impl.changePassword(payload);
            })
        };

        async function maybeAutosave_() {
            const answered = payload?.state?.answeredCount || 0;
            if (answered - _lastSavedAnswerCount < AUTOSAVE_EVERY) return;

            // Buffer-full flush: persist pending changes now.
            try {
                flushPendingSaves_('count', { forceProgress: true });
            } catch (e) {
                // ignore
            }
        }

        // Straightforward save policy (fast UI, fewer writes):
        // - Keep changes in memory immediately
        // - Persist in the background on buffer fill OR after a timeout, whichever comes first
        // - Also persist on tab hide/unload
        const PENDING_SAVE_FLUSH_DELAY_MS = 15000;
        let _pendingSaveFlushTimer = null;

        function schedulePendingSaveFlush_() {
            try {
                if (_pendingSaveFlushTimer) return;
                _pendingSaveFlushTimer = setTimeout(() => {
                    _pendingSaveFlushTimer = null;
                    flushPendingSaves_('timer');
                    // If more changes accumulated while saving, schedule another tick.
                    if (payload?.state?._progressDirty || payload?.state?._dailyCapDirty) {
                        schedulePendingSaveFlush_();
                    }
                }, PENDING_SAVE_FLUSH_DELAY_MS);
            } catch (e) {
                // ignore
            }
        }

        function markProgressDirty_() {
            try {
                if (!payload || payload?._isMock) return;
                if (!payload.state || typeof payload.state !== 'object') payload.state = {};
                payload.state._progressDirty = true;
                schedulePendingSaveFlush_();
            } catch (e) {
                // ignore
            }
        }

        function markDailyCapDirty_() {
            try {
                if (!payload || payload?._isMock) return;
                if (!payload.state || typeof payload.state !== 'object') payload.state = {};
                payload.state._dailyCapDirty = true;
                schedulePendingSaveFlush_();
            } catch (e) {
                // ignore
            }
        }

        function flushPendingSaves_(reason = '', { forceProgress = false } = {}) {
            try {
                if (!payload || payload?._isMock) return { progress: false, dailyCap: false };
                if (!payload.state || typeof payload.state !== 'object') payload.state = {};

                const answered = Number(payload.state.answeredCount || 0);
                const progressDirty = !!payload.state._progressDirty;
                const dailyCapDirty = !!payload.state._dailyCapDirty;

                let didProgress = false;
                let didDailyCap = false;

                if (forceProgress || progressDirty) {
                    // Avoid re-sending the same snapshot if nothing changed since last save.
                    if (answered > _lastSavedAnswerCount) {
                        const cardWidth = Object.keys(STUDY_SET_SCHEMA).length;
                        const userProgress = payload.items.map(row => row.slice(cardWidth));
                        SaveQueue.add('progress', { saveType: 'progress', data: userProgress });
                        _lastSavedAnswerCount = answered;
                        didProgress = true;
                    }
                    payload.state._progressDirty = false;
                }

                if (dailyCapDirty) {
                    const deckOnly = stripGlobalSettingsFromArray(settings || []);
                    SaveQueue.add('deckSettings', { saveType: 'deckSettings', data: deckOnly }, { silent: true });
                    payload.state._dailyCapDirty = false;
                    didDailyCap = true;
                }

                return { progress: didProgress, dailyCap: didDailyCap };
            } catch (e) {
                return { progress: false, dailyCap: false };
            }
        }

        (function installPendingSaveFlushHooks_() {
            try {
                if (window.__pendingSaveHooksInstalled) return;
                window.__pendingSaveHooksInstalled = true;

                // Flush on tab hide / navigation / reload so pending changes survive reload.
                window.addEventListener('beforeunload', () => {
                    try { flushPendingSaves_('beforeunload'); } catch (e) { }
                });
                document.addEventListener('visibilitychange', () => {
                    try {
                        if (document.visibilityState === 'hidden') flushPendingSaves_('hidden');
                    } catch (e) { }
                });
            } catch (e) {
                // ignore
            }
        })();

        function parseDue_(v) {
            if (!v) return 0;
            if (v instanceof Date) return isNaN(v.getTime()) ? 0 : v;
            if (typeof v === 'number') {
                const dn = new Date(v);
                return isNaN(dn.getTime()) ? 0 : dn;
            }
            const s = String(v).trim();
            if (!s) return 0;

            // Preferred format across frontend + backend: "YYYY-MM-DD HH:MM:SS" (local time, no timezone).
            // Do NOT rely on Date.parse for this format; explicitly parse for consistency.
            const mDateTime = s.match(/^(\d{4})-(\d{2})-(\d{2})[ T](\d{2}):(\d{2}):(\d{2})$/);
            if (mDateTime) {
                const y = Number(mDateTime[1]);
                const mo = Number(mDateTime[2]);
                const d0 = Number(mDateTime[3]);
                const hh = Number(mDateTime[4]);
                const mi = Number(mDateTime[5]);
                const ss = Number(mDateTime[6]);
                const dt = new Date(y, mo - 1, d0, hh, mi, ss, 0);
                return isNaN(dt.getTime()) ? 0 : dt;
            }

            // Date-only format: "YYYY-MM-DD" -> local midnight
            const mDateOnly = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
            if (mDateOnly) {
                const y = Number(mDateOnly[1]);
                const mo = Number(mDateOnly[2]);
                const d0 = Number(mDateOnly[3]);
                const dt = new Date(y, mo - 1, d0, 0, 0, 0, 0);
                return isNaN(dt.getTime()) ? 0 : dt;
            }

            // Back-compat: accept ISO strings (e.g. previous "YYYY-MM-DDTHH:mm:ssZ").
            const d = new Date(s);
            return isNaN(d.getTime()) ? 0 : d;
        }

        function parseLadder_(raw) {
            const txt = String(raw || '').trim();
            if (!txt) return [];
            const parts = txt.replace(/[{}]/g, '').split(';').map(s => s.trim()).filter(Boolean);
            return parts.map(p => {
                if (p.includes('/')) {
                    const [num, den] = p.split('/').map(Number);
                    if (Number.isFinite(num) && Number.isFinite(den) && den > 0) return num / den; // days as decimal
                }
                const n = Number(p);
                return Number.isFinite(n) ? n : 0;
            }).map(d => Math.max(0, d));
        }

        function getEffectiveDeckLadderString_(setSettings) {
            try {
                const raw = (setSettings && Object.prototype.hasOwnProperty.call(setSettings, 'Ladder'))
                    ? String(setSettings.Ladder || '')
                    : '';

                const parsed = parseLadder_(raw);
                const isValid = Array.isArray(parsed) && parsed.length > 0 && parsed.some(v => Number.isFinite(v) && v > 0);
                return isValid ? raw : DEFAULT_LADDER_STR;
            } catch {
                return DEFAULT_LADDER_STR;
            }
        }

        function getEffectiveDeckLadder_(setSettings) {
            const ladder = parseLadder_(getEffectiveDeckLadderString_(setSettings));
            // Defensive: should never be empty because DEFAULT_LADDER_STR is non-empty.
            return (Array.isArray(ladder) && ladder.length > 0) ? ladder : [1];
        }


        let _audioEnabled = false;
        let _currentAudioUrl = '';
        let _audioRequestId = 0;

        function initAudioStateFromSettings() {
            try {
                const val = getSetting('AudioAutoPlay');
                _audioEnabled = (val === true || val === 'true');
            } catch (e) {
                _audioEnabled = true;
            }
        }

        function resolveAudioUrlForRow(row) {
            const C = payload.schema.lexiconCols || buildLexiconSchema(STUDY_SET_SCHEMA, USER_PROGRESS_SCHEMA);

            // TTS from term (audio column removed from schema)
            const term = (row && row[C.term] != null) ? String(row[C.term]).trim() : '';
            if (!term) return '';

            if (!payload?.setSettings) throw new Error('Missing payload.setSettings');
            const lang = String(payload.setSettings.Lang || 'en').trim();

            // Route through Cloudflare Worker proxy to bypass CORS
            const ttsUrl = `https://translate.google.com/translate_tts?ie=UTF-8&client=tw-ob&tl=${encodeURIComponent(lang)}&q=${encodeURIComponent(term)}`;
            return `${API_URL}?action=audio&url=${encodeURIComponent(ttsUrl)}`;
        }

        async function playAudioUrl(url) {
            if (!url) return false;

            const audio = _audioEl || initAudioElement();
            const requestId = ++_audioRequestId;

            try {
                audio.pause();
                audio.currentTime = 0;
            } catch { }

            try {
                if (requestId !== _audioRequestId) return false;

                log_('[Audio] Playing URL:', url);
                audio.src = url;

                let rate = 1;
                try {
                    const currentIndex = payload?.state?.currentIndex;
                    if (currentIndex >= 0 && payload?.items) {
                        const C = payload.schema.lexiconCols;
                        const row = payload.items[currentIndex];
                        const term = String(row[C.term] || '').trim();
                        rate = term.length <= 5 ? 1 : (Number(getSetting('PlaybackSpeed')) || 1.5);
                    } else {
                        rate = Number(getSetting('PlaybackSpeed')) || 1.5;
                    }
                } catch (e) {
                    rate = 1;
                }

                audio.playbackRate = rate;

                if (requestId !== _audioRequestId) return false;

                await audio.play();
                log_('[Audio] Playing successfully');

                return true;
            } catch (e) {
                log_('[Audio] Play failed:', e.message);
                return false;
            }
        }

        function updateAudioUIForCurrentRow(hasAudio) {
            const audioBtn = $('audioBtn');
            const termEl = $('termText');
            if (!audioBtn || !termEl) return;

            audioBtn.hidden = !hasAudio;

            if (!hasAudio) {
                audioBtn.disabled = true;
                audioBtn.setAttribute('aria-pressed', 'false');
                termEl.style.cursor = 'default';
                termEl.onclick = null;
                audioBtn.onclick = null;
                return;
            }

            audioBtn.disabled = false;
            const isAudioOnly = audioBtn.classList.contains('audio-only-mode');

            // Icon according to current toggle state
            audioBtn.textContent = _audioEnabled ? 'üîä' : 'üîá';
            audioBtn.setAttribute('aria-pressed', _audioEnabled ? 'true' : 'false');

            // Term click: always replays when audio is present (regardless of toggle)
            termEl.style.cursor = _audioEnabled ? 'pointer' : 'default';
            termEl.onclick = (_audioEnabled && _currentAudioUrl)
                ? () => { playAudioUrl(_currentAudioUrl); }
                : null;

            // Button click: in AudioOnly mode always replay, otherwise toggle
            audioBtn.onclick = () => {
                // Check if we're in AudioOnly mode
                const isAudioOnly = audioBtn.classList.contains('audio-only-mode');

                if (isAudioOnly) {
                    // AudioOnly mode: always replay
                    playAudioUrl(_currentAudioUrl);
                    return;
                }

                // Normal mode: toggle audio on/off
                _audioEnabled = !_audioEnabled;

                // Stop audio if turning off
                if (!_audioEnabled) {
                    const audio = _audioEl || initAudioElement();
                    if (audio && !audio.paused) {
                        try {
                            audio.pause();
                            audio.currentTime = 0;
                        } catch (e) {
                            log_('failed to stop audio', e);
                        }
                    }
                }

                // Mirror back into settings so it can be persisted
                try {
                    const row = settings.find(r =>
                        Array.isArray(r) && String(r[0]) === 'AudioAutoPlay'
                    );
                    if (row) {
                        row[1] = _audioEnabled;
                    }
                } catch (e) {
                    log_('failed to mirror AudioAutoPlay to settings', e);
                }

                updateAudioUIForCurrentRow(hasAudio);
            };
        }

        function setFeedback_(html) {
            const fb = $('feedback');
            if (fb) fb.innerHTML = html || '';
        }

        function computeSessionStats() {
            if (!payload || !Array.isArray(payload.items)) {
                return { remainingNew: 0, remainingReview: 0 };
            }
            const C = payload.schema.lexiconCols || buildLexiconSchema(STUDY_SET_SCHEMA, USER_PROGRESS_SCHEMA);
            const now = Date.now();

            // For the status bar counters, use strict "due now" semantics.
            // The MIN_REVIEW_INTERVAL_MS window is a study/selection affordance,
            // but for stats users expect Review to drop once a card is rescheduled.
            const isDueForStats = (due) => (due instanceof Date) && (due.getTime() <= now);

            const baseNewLimit = getSetting('NewItemsPerDay', true);
            const extraNew = Number(payload?.state?.extraNewItems || 0);
            const limitNew = baseNewLimit + extraNew;
            // Persisted daily cap counter (deck setting) so New survives reloads.
            const dailyLearned = Number(getSettingSafe_('DailyNewCount', 0, true) || 0);
            const remainingNew = Math.max(0, limitNew - (Number.isFinite(dailyLearned) ? dailyLearned : 0));

            // Session-only learned-new count: used only to make Review reflect newly-learned cards
            // that were rescheduled into the future during *this* run.
            const learnedNewCount = Number(payload?.state?.learnedNewCount || 0);

            let remainingReview = 0;
            for (const row of payload.items) {
                if (!row) continue;
                if (row[C.suspended]) continue;
                const due = parseDue_(row[C.due]);
                if (isDueForStats(due)) remainingReview++;
            }

            // Ensure each learned-new card increments Review once, without double-counting
            // if it's already included in the due-based review count.
            try {
                const learned = payload?.state?.learnedNewByIndex;
                if (learned && typeof learned === 'object') {
                    let learnedAlreadyDue = 0;
                    for (const k of Object.keys(learned)) {
                        if (!learned[k]) continue;
                        const idx = Number(k);
                        if (!Number.isFinite(idx) || idx < 0 || idx >= payload.items.length) continue;
                        const row = payload.items[idx];
                        if (!row || row[C.suspended]) continue;
                        const due = parseDue_(row[C.due]);
                        if (isDueForStats(due)) learnedAlreadyDue++;
                    }
                    const extraReview = Math.max(0, learnedNewCount - learnedAlreadyDue);
                    remainingReview += extraReview;
                } else {
                    remainingReview += learnedNewCount;
                }
            } catch (e) {
                remainingReview += learnedNewCount;
            }
            return { remainingNew, remainingReview };
        }

        function updateSessionStats() {
            const el = $('statusBarText');
            if (!el) return;
            const stats = computeSessionStats();
            const deckName = payload?.activeSet || '';

            // Build HTML with explicit direction control to prevent RTL/LTR mixing issues
            if (deckName) {
                el.innerHTML = `<span dir="auto">${deckName}</span><span dir="ltr"> - Answered: ${payload.state.answeredCount}, New: ${stats.remainingNew}, Review: ${stats.remainingReview}</span>`;
            } else {
                el.textContent = `Answered: ${payload.state.answeredCount}, New: ${stats.remainingNew}, Review: ${stats.remainingReview}`;
            }
        }

        function setProgress() {
            updateSessionStats();
        }

        function countRemainingNewItems() {
            if (!payload || !Array.isArray(payload.items)) return 0;
            const C = payload.schema?.lexiconCols || buildLexiconSchema(STUDY_SET_SCHEMA, USER_PROGRESS_SCHEMA);
            return payload.items.reduce((acc, row) => {
                if (!row) return acc;
                if (row[C.suspended]) return acc;
                const due = parseDue_(row[C.due]);
                const reps = Number(row[C.reps] || 0);
                const step = Number(row[C.step] || 0);
                const isNew = reps === 0 && step === 0 && !(due instanceof Date);
                return acc + (isNew ? 1 : 0);
            }, 0);
        }

        let settingsDraft = null;
        // Store original theme when opening settings so that Cancel can revert preview
        let _themePreviewOriginal = null;
        // Store original in-memory settings so Cancel can revert previewed changes
        let _settingsPreviewOriginal = null;
        let _userPreferencesPreviewOriginal = null;
        let _payloadSettingsPreviewOriginal = null;
        let _payloadUserPreferencesPreviewOriginal = null;
        // 2025-11-07 13:40 IDT ‚Äî Settings as matrix: render using schema indices
        const THEME_SETTING_NAME = 'ThemeLight';

        function cloneSettingsMatrix_(rows) {
            if (!Array.isArray(rows)) return [];
            return rows.map(r => Array.isArray(r) ? r.slice() : []);
        }

        function setMatrixValue_(rows, name, value) {
            if (!Array.isArray(rows) || !name) return rows;
            const key = String(name);
            const idx = rows.findIndex(r => Array.isArray(r) && String(r[0]) === key);
            if (idx >= 0) {
                rows[idx][1] = value;
            } else {
                rows.push([key, value]);
            }
            return rows;
        }

        function getLocalDayKey_() {
            const d = new Date();
            const pad2 = (n) => String(n).padStart(2, '0');
            return `${d.getFullYear()}-${pad2(d.getMonth() + 1)}-${pad2(d.getDate())}`;
        }

        function getSettingSafe_(name, fallbackValue, asNumber = false) {
            try {
                return getSetting(name, asNumber);
            } catch (e) {
                return fallbackValue;
            }
        }

        // Deck settings (sheet-backed) are a fixed-size matrix (rows between row 2 and the header).
        // Only overwrite existing keys or fill empty slots; do NOT grow unless explicitly allowed (mock mode).
        function setMatrixValueFixed_(rows, name, value, { allowGrow = false } = {}) {
            if (!Array.isArray(rows) || !name) return false;
            const key = String(name);
            const idx = rows.findIndex(r => Array.isArray(r) && String(r[0]) === key);
            if (idx >= 0) {
                rows[idx][1] = value;
                return true;
            }
            const emptyIdx = rows.findIndex(r => Array.isArray(r) && !String(r[0] ?? '').trim());
            if (emptyIdx >= 0) {
                rows[emptyIdx][0] = key;
                rows[emptyIdx][1] = value;
                return true;
            }
            if (allowGrow) {
                rows.push([key, value]);
                return true;
            }
            return false;
        }

        function normalizeDailyNewCap_({ persist = false } = {}) {
            if (!payload) return false;
            if (!Array.isArray(settings)) return false;
            const todayKey = getLocalDayKey_();
            const allowGrow = !!payload?._isMock;

            const storedDay = String(getSettingSafe_('DailyNewDayKey', '', false) || '').trim();
            const storedCountRaw = Number(getSettingSafe_('DailyNewCount', 0, true) || 0);
            const storedCount = Number.isFinite(storedCountRaw) ? storedCountRaw : 0;
            const needsReset = !storedDay || storedDay !== todayKey;

            let changed = false;
            if (needsReset) {
                changed = setMatrixValueFixed_(settings, 'DailyNewDayKey', todayKey, { allowGrow }) || changed;
                changed = setMatrixValueFixed_(settings, 'DailyNewCount', 0, { allowGrow }) || changed;
                if (Array.isArray(payload.settings)) {
                    changed = setMatrixValueFixed_(payload.settings, 'DailyNewDayKey', todayKey, { allowGrow }) || changed;
                    changed = setMatrixValueFixed_(payload.settings, 'DailyNewCount', 0, { allowGrow }) || changed;
                }
            } else {
                changed = setMatrixValueFixed_(settings, 'DailyNewDayKey', storedDay, { allowGrow }) || changed;
                changed = setMatrixValueFixed_(settings, 'DailyNewCount', storedCount, { allowGrow }) || changed;
                if (Array.isArray(payload.settings)) {
                    changed = setMatrixValueFixed_(payload.settings, 'DailyNewDayKey', storedDay, { allowGrow }) || changed;
                    changed = setMatrixValueFixed_(payload.settings, 'DailyNewCount', storedCount, { allowGrow }) || changed;
                }
            }

            if (persist && changed && !payload?._isMock) {
                try {
                    const deckOnly = stripGlobalSettingsFromArray(settings || []);
                    SaveQueue.add('deckSettings', { saveType: 'deckSettings', data: deckOnly }, { silent: true });
                } catch (e) {
                    log_('[DailyCap] persist failed:', e);
                }
            }

            return changed;
        }

        function applyLiveSettingPreview_(name, value) {
            try {
                // Always mirror into the live combined settings matrix used by getSetting()
                if (Array.isArray(settings)) {
                    setMatrixValue_(settings, name, value);
                }
                if (payload && Array.isArray(payload.settings)) {
                    setMatrixValue_(payload.settings, name, value);
                }

                // If editing user preferences, also mirror into userPreferences (and payload.userPreferences)
                if (settingsViewMode === 'user') {
                    if (!Array.isArray(userPreferences)) userPreferences = [];
                    setMatrixValue_(userPreferences, name, value);
                    if (payload) {
                        if (!Array.isArray(payload.userPreferences)) payload.userPreferences = [];
                        setMatrixValue_(payload.userPreferences, name, value);
                    }
                }

                // Immediate UI/behavior updates
                if (name === 'NewItemsPerDay' || name === 'TestDueDate') {
                    // Avoid clobbering the Test Mode status bar
                    if (!testState) updateSessionStats();
                }
                if (name === 'QuizMode') {
                    // Apply new mode immediately to the next render
                    if (testState) {
                        renderTestQuestion();
                    } else if (payload && payload.state && payload.state.currentIndex >= 0) {
                        renderTerm();
                    }
                }
            } catch (e) {
                log_('applyLiveSettingPreview_ failed', e);
            }
        }

        function applyTheme(val) {
            // Accept an explicit value to preview a change while editing settings
            const body = document.body;
            if (!body) return;
            let isLight = true;
            try {
                let v = val;
                if (v === undefined) v = getSetting(THEME_SETTING_NAME);
                isLight = v === true || v === 'true';
            } catch (e) {
                isLight = true;
            }
            body.dataset.theme = isLight ? 'light' : 'dark';
        }

        function renderSettingsUI(bundle) {
            try {
                const panel = $('settingsWrap');
                const grid = $('settingsGrid');
                const hint = $('settingsHint');
                if (!panel || !grid) return;

                const rows = Array.isArray(settingsDraft)
                    ? settingsDraft
                    : (Array.isArray(bundle?.settings)
                        ? bundle.settings.map(r => Array.isArray(r) ? r.slice() : [])
                        : []);

                settingsDraft = rows;
                grid.innerHTML = '';

                const canShow = (row) => {
                    if (!Array.isArray(row) || !row.length) return false;
                    const name = String(row[0] || '').trim();
                    if (!name) return false;
                    if (name === 'UserID' || name === 'Setting' || name === 'Password') return false; // hide header/user rows
                    if (name === 'DailyNewDayKey' || name === 'DailyNewCount') return false; // hide daily cap rows
                    return true;
                };
                const autoNewCtx = { newCtrl: null, newRow: null, dueCtrl: null };

                const syncAutoNewRate = () => {
                    const ctrl = autoNewCtx.newCtrl;
                    if (!ctrl || !autoNewCtx.newRow) return;
                    ctrl.disabled = false;
                    ctrl.title = '';
                    const dueCtrl = autoNewCtx.dueCtrl;
                    if (!dueCtrl || !dueCtrl.value) return;
                    const dueDate = new Date(dueCtrl.value);
                    if (isNaN(dueDate.getTime())) return;
                    const today = new Date();
                    let daysUntil = Math.floor((dueDate - today) / 86400000);
                    if (daysUntil <= 0) return;
                    let days = daysUntil - 7;
                    if (days <= 0) {
                        days = Math.max(1, Math.floor(daysUntil / 2));
                    }
                    const totalNew = countRemainingNewItems();
                    if (!totalNew) return;
                    days = Math.max(days, 1);
                    const perDay = Math.max(5, Math.ceil(totalNew / days));
                    ctrl.value = perDay;
                    autoNewCtx.newRow[1] = perDay;
                    applyLiveSettingPreview_('NewItemsPerDay', perDay);
                    ctrl.disabled = true;
                    ctrl.title = 'Auto-calculated from TestDueDate';
                };

                const visible = rows.filter(r => canShow(r));
                if (!visible.length) {
                    panel.hidden = true;
                    return;
                }
                panel.hidden = false;
                hint.textContent = '';

                for (const r of visible) {
                    const name = String(r[0] ?? '');
                    const value = r[1];
                    const editable = canShow(r);
                    const isRO = !editable;

                    const label = document.createElement('div');
                    label.className = 'label';
                    label.textContent = name;

                    const ctrlWrap = document.createElement('div');
                    ctrlWrap.className = 'control';
                    ctrlWrap.dataset.readonly = isRO ? '1' : '0';

                    let ctrl = null;
                    const updateSettingValue = () => {
                        if (!ctrl) return;
                        if (name === 'QuizMode' || name === 'ThemeLight' || name === 'AudioAutoPlay') {
                            r[1] = ctrl.value === 'true';
                        } else if (name === 'NewItemsPerDay' || name === 'PlaybackSpeed') {
                            r[1] = Number(ctrl.value);
                        } else {
                            r[1] = ctrl.value;
                        }
                        if (name === 'ThemeLight') {
                            // Pass explicit value so the preview updates immediately while editing
                            applyTheme(r[1]);
                        }
                        applyLiveSettingPreview_(name, r[1]);
                    };
                    if (name === 'TestDueDate') {
                        ctrl = document.createElement('input');
                        ctrl.type = 'date';
                        const v = String(value ?? '').trim();
                        let isoVal = v;
                        // Ensure it's in YYYY-MM-DD format
                        if (!/^\d{4}-\d{2}-\d{2}$/.test(isoVal)) {
                            const d = new Date();
                            isoVal = `${d.getUTCFullYear()}-${String(d.getUTCMonth() + 1).padStart(2, '0')}-${String(d.getUTCDate()).padStart(2, '0')}`;
                            r[1] = isoVal;
                        }
                        ctrl.value = isoVal;
                        ctrl.placeholder = 'YYYY-MM-DD';
                        ctrl.id = `setting_${name}`;
                        autoNewCtx.dueCtrl = ctrl;
                    } else if (name === 'NewItemsPerDay') {
                        ctrl = document.createElement('input');
                        ctrl.type = 'number';
                        ctrl.value = String(value ?? '');
                    } else if (name === 'PlaybackSpeed') {
                        // Render playback speed with centered numeric value ABOVE the slider
                        const wrapper = document.createElement('div');
                        wrapper.style.display = 'flex';
                        wrapper.style.flexDirection = 'column';
                        wrapper.style.alignItems = 'center';

                        const valueEl = document.createElement('div');
                        valueEl.style.textAlign = 'center';
                        valueEl.style.marginBottom = '6px';
                        valueEl.className = 'playback-value';

                        const parsedVal = Number(value);
                        const initialVal = Number.isFinite(parsedVal) ? parsedVal : 1.5;
                        if (DEBUG_MODE === 'Fireglass' && DEBUG_PLAYBACK_SPEED_LOGS) {
                            log_('[PlaybackSpeed] row value=', value, 'parsedVal=', parsedVal, 'initialVal=', initialVal);
                        }

                        ctrl = document.createElement('input');
                        ctrl.type = 'range';
                        ctrl.min = '0.25';
                        ctrl.max = '4';
                        ctrl.step = '0.25';
                        ctrl.value = String(initialVal);
                        if (DEBUG_MODE === 'Fireglass' && DEBUG_PLAYBACK_SPEED_LOGS) {
                            log_('[PlaybackSpeed] ctrl.value after set=', ctrl.value);
                        }
                        r[1] = initialVal; // keep row normalized and in sync with the slider
                        // Force LTR on the slider to prevent RTL reversal (thumb position must match value)
                        ctrl.style.direction = 'ltr';
                        ctrl.setAttribute('dir', 'ltr');
                        // Do not force full-width here; let the existing
                        // `.settings-grid input` CSS rules control sizing so the
                        // slider matches other controls exactly.
                        ctrl.style.margin = '0';
                        ctrl.style.padding = '0';

                        // Put the numeric value above the slider in the center
                        wrapper.appendChild(valueEl);
                        wrapper.appendChild(ctrl);
                        // Place wrapper into ctrlWrap instead of raw ctrl element
                        ctrlWrap.appendChild(wrapper);
                        // Mark ctrl as already appended so later code does not append again
                        ctrl._appendedViaWrapper = true;
                    } else if (name === 'QuizMode' || name === 'ThemeLight' || name === 'AudioAutoPlay') {
                        ctrl = document.createElement('select');
                        const opts = [['true', 'Yes'], ['false', 'No']];
                        for (const [val, label] of opts) {
                            const o = document.createElement('option');
                            o.value = val;
                            o.textContent = label;
                            if (String(value) === val) o.selected = true;
                            ctrl.appendChild(o);
                        }
                    } else {
                        ctrl = document.createElement('input');
                        ctrl.type = 'text';
                        ctrl.value = String(value ?? '');
                    }

                    if (name === 'NewItemsPerDay' && ctrl) {
                        autoNewCtx.newCtrl = ctrl;
                        autoNewCtx.newRow = r;
                    }

                    if (ctrl) {
                        ctrl.id = `setting_${name}`;
                        if (isRO) {
                            ctrl.disabled = true;
                            ctrl.title = 'Read-only';
                        } else {
                            if (name === 'TestDueDate') {
                                ctrl.addEventListener('input', () => {
                                    updateSettingValue();
                                    syncAutoNewRate();
                                });
                            } else {
                                ctrl.addEventListener('input', updateSettingValue);
                            }
                        }
                        // If we already appended the ctrl inside a wrapper (PlaybackSpeed), skip appending here
                        if (!ctrl._appendedViaWrapper) {
                            ctrlWrap.appendChild(ctrl);
                        }
                    }

                    grid.appendChild(label);
                    grid.appendChild(ctrlWrap);

                    // Show current numeric value for PlaybackSpeed ABOVE the slider and centered
                    if (name === 'PlaybackSpeed' && ctrl) {
                        try {
                            const fmt = (v) => {
                                const n = Number(v);
                                if (!Number.isFinite(n)) return String(v);
                                return n.toFixed(2).replace(/\.?(0+)$/, '').replace(/\.$/, '');
                            };

                            // Find the playback value element we created earlier (if any)
                            const pv = ctrlWrap.querySelector('.playback-value');
                            if (pv) {
                                pv.textContent = `√ó${fmt(ctrl.value)}`;
                                ctrl.addEventListener('input', () => {
                                    pv.textContent = `√ó${fmt(ctrl.value)}`;
                                });
                            }
                        } catch (e) {
                            log_('Failed to attach PlaybackSpeed display', e);
                        }
                    }
                }
                syncAutoNewRate();
            } catch (e) {
                log_('renderSettingsUI failed', e);
            }
        }

        function autoAdjustNewItemsPerDay() {
            try {
                const dueStr = getSetting('TestDueDate');
                if (!dueStr) return;
                const dueDate = new Date(dueStr);
                if (isNaN(dueDate.getTime())) return;

                const totalNew = countRemainingNewItems();
                if (!totalNew) return;

                const today = new Date();
                let daysUntil = Math.floor((dueDate - today) / 86400000);
                if (daysUntil <= 0) return;
                let usableDays = daysUntil - 7;
                if (usableDays <= 0) {
                    usableDays = Math.max(1, Math.floor(daysUntil / 2));
                }
                const perDay = Math.max(5, Math.ceil(totalNew / usableDays));

                const newRow = (payload.settings || settings).find(r =>
                    Array.isArray(r) && String(r[0]) === 'NewItemsPerDay'
                );
                if (newRow) {
                    newRow[1] = perDay;
                    settings = settings.map(r => Array.isArray(r) ? r.slice() : []);
                    const row = settings.find(r => Array.isArray(r) && String(r[0]) === 'NewItemsPerDay');
                    if (row) row[1] = perDay;
                }
            } catch (err) {
                log_('autoAdjustNewItemsPerDay failed', err);
            }
        }

        function getSetting(name, asNumber = false) {
            const rows = Array.isArray(settings) ? settings : [];
            const row = rows.find(r =>
                Array.isArray(r) && String(r[0]) === String(name)
            );
            if (!row || row[1] == null) {
                // Fallback to credentials (persisted global settings) if present
                try {
                    const prefRow = (Array.isArray(userPreferences) ? userPreferences : []).find(r => Array.isArray(r) && String(r[0]) === String(name));
                    if (prefRow && prefRow[1] != null) {
                        const val = prefRow[1];
                        return asNumber ? Number(val) : String(val).trim();
                    }
                    if (currentCredentials && currentCredentials[name] !== undefined) {
                        const val = currentCredentials[name];
                        return asNumber ? Number(val) : String(val).trim();
                    }
                } catch (e) { /* ignore */ }
                throw new Error(`Missing setting: ${name}`);
            }
            const raw = row[1];
            if (!asNumber) return String(raw).trim();

            const n = Number(raw);
            if (!Number.isFinite(n)) {
                throw new Error(`Setting ${name} must be a finite number`);
            }
            return n;
        }

        function startTestMode() {
            if (!payload || !payload.items || payload.items.length === 0) {
                showError_('No study set loaded');
                return;
            }

            // Initialize test state - exclude suspended cards
            const C = payload.schema.lexiconCols;
            const indices = [];
            for (let i = 0; i < payload.items.length; i++) {
                const row = payload.items[i];
                if (row && !row[C.suspended]) {
                    indices.push(i);
                }
            }

            if (indices.length === 0) {
                showError_('No cards available for testing (all suspended)');
                return;
            }

            testState = {
                activeSet: payload.activeSet || 'Test',
                shuffledIndices: shuffleArray(indices),
                currentIndex: 0,
                score: 0,
                startTime: new Date(),
                totalQuestions: indices.length,
                sessionId: Date.now() + '_' + Math.random().toString(36).substr(2, 9)
            };

            // Update menu item
            const label = $('testModeLabel');
            const icon = $('testModeIcon');
            if (label) label.textContent = 'Learn Mode';
            if (icon) icon.textContent = 'üìö';

            // Update UI for test mode
            $('quizArea').classList.remove('hidden');
            $('doneArea').classList.add('hidden');

            renderTestQuestion();
        }

        function suspendCurrentTestCard() {
            if (!testState) return;
            const actualIndex = testState.shuffledIndices[testState.currentIndex];
            const C = payload.schema.lexiconCols;
            const row = payload.items[actualIndex];
            row[C.suspended] = true;

            // Skip to next question
            testState.currentIndex++;
            renderTestQuestion();
        }

        function renderTestQuestion() {
            // Stop any playing audio
            const audio = _audioEl || initAudioElement();
            if (audio && !audio.ended && !audio.paused) {
                try {
                    audio.pause();
                    audio.currentTime = 0;
                } catch (e) {
                    log_('Failed to stop audio:', e);
                }
            }

            if (!testState || testState.currentIndex >= testState.shuffledIndices.length) {
                showTestResults();
                return;
            }

            const actualIndex = testState.shuffledIndices[testState.currentIndex];
            const row = payload.items[actualIndex];
            const C = payload.schema.lexiconCols;

            // Update progress - show number of questions answered so far
            const sb = $('statusBarText');
            const percentage = testState.currentIndex > 0 ? Math.round((testState.score / testState.currentIndex) * 100) : 0;
            const deckName = testState.activeSet || '';
            if (sb) {
                if (deckName) {
                    sb.innerHTML = `<span dir="auto">${deckName}</span><span dir="ltr"> - Questions: ${testState.currentIndex} ¬∑ Score: ${percentage}%</span>`;
                } else {
                    sb.textContent = `Questions: ${testState.currentIndex} ¬∑ Score: ${percentage}%`;
                }
            }

            // Determine question mode based on QuizMode setting (same as Learn Mode)
            const { effectiveMode, optionsBundle } = determineQuestionMode(actualIndex);
            const isMCQ = (effectiveMode === 'MultipleChoice');

            const term = String(row[C.term]);
            const def = String(row[C.definition]);
            const qEl = $('termText');
            const answersEl = $('answers');
            const termHeader = $('termHeader');
            const suspendBtn = $('suspendBtn');

            // Show suspend button in test mode
            if (suspendBtn) {
                suspendBtn.hidden = false;
                suspendBtn.onclick = () => {
                    showConfirm('Suspend this card? It will be hidden from study and tests.', () => {
                        suspendCurrentTestCard();
                    });
                };
            }

            const isAudioOnly = payload?.setSettings?.AudioOnly === true || payload?.setSettings?.AudioOnly === 'true';
            setupAudioForRow(row, isAudioOnly);
            setupImageForRow(row, term);

            setFeedback_('');
            answersEl.innerHTML = '';
            answersEl.classList.toggle('is-flash', !isMCQ);

            if (isMCQ) {
                // MCQ mode
                termHeader?.removeAttribute('data-hide');
                qEl.classList.add('autoshrink');
                qEl.textContent = term;

                if (optionsBundle.options.length === 0) {
                    showError_('Cannot generate test question for this item');
                    return;
                }

                answersEl.dataset.count = String(optionsBundle.options.length);
                const correctIndex = optionsBundle.correctIndex;
                for (let i = 0; i < optionsBundle.options.length; i++) {
                    const btn = document.createElement('button');
                    btn.className = 'answer';
                    const span = document.createElement('span');
                    span.className = 'answer-label';
                    span.setAttribute('dir', 'auto');
                    span.textContent = optionsBundle.options[i] || '';
                    btn.appendChild(span);
                    btn.onclick = () => onTestAnswer(i, correctIndex);
                    answersEl.appendChild(btn);
                }
            } else {
                // FlashCard mode
                delete answersEl.dataset.count;
                termHeader?.removeAttribute('data-hide');
                qEl.classList.add('autoshrink');
                qEl.textContent = term;
                renderFlashCard(term, def);

                // Update flash card buttons to use onTestAnswer
                const okBtn = document.querySelector('.fc-btn.correct');
                const noBtn = document.querySelector('.fc-btn.wrong');
                if (okBtn && noBtn) {
                    const FLASH_CORRECT = 0;
                    okBtn.onclick = () => onTestAnswer(FLASH_CORRECT, FLASH_CORRECT);
                    noBtn.onclick = () => onTestAnswer(-1, FLASH_CORRECT);
                }
            }

            setTimeout(autoshrinkAll, 0);
        }

        function onTestAnswer(chosenIndex, correctIndex) {
            const isCorrect = chosenIndex === correctIndex;
            if (isCorrect) testState.score++;

            // Update status bar immediately after answer
            testState.currentIndex++;
            const sb = $('statusBarText');
            const percentage = Math.round((testState.score / testState.currentIndex) * 100);
            const deckName = testState.activeSet || '';
            if (sb) {
                if (deckName) {
                    sb.innerHTML = `<span dir="auto">${deckName}</span><span dir="ltr"> - Questions: ${testState.currentIndex} ¬∑ Score: ${percentage}%</span>`;
                } else {
                    sb.textContent = `Questions: ${testState.currentIndex} ¬∑ Score: ${percentage}%`;
                }
            }

            // Show feedback
            const btns = Array.from(document.querySelectorAll('.answer'));
            btns.forEach(b => {
                b.disabled = true;
                b.classList.remove('correct', 'wrong', 'selected-wrong');
            });

            if (isCorrect) {
                setFeedback_('<span class="success">‚úì Correct</span>');
                if (btns[correctIndex]) btns[correctIndex].classList.add('correct');
            } else {
                setFeedback_('<span class="error">‚úó Incorrect. Tap/click anywhere or press any key to continue</span>');
                if (chosenIndex >= 0 && btns[chosenIndex]) btns[chosenIndex].classList.add('wrong', 'selected-wrong');
                if (btns[correctIndex]) btns[correctIndex].classList.add('correct');
            }

            // Auto-save every 10 questions (background)
            if (testState.currentIndex % 10 === 0) {
                saveTestProgress().catch(e => log_('Background test save failed:', e));
            }

            // Continue with same pattern as learn mode
            let continueTimer = null;
            const done = () => {
                if (continueTimer) {
                    clearTimeout(continueTimer);
                    continueTimer = null;
                }
                document.removeEventListener('keydown', onKey, true);
                document.removeEventListener('click', onClick, true);
                renderTestQuestion();
            };
            const onKey = (e) => done();
            const onClick = (e) => done();
            document.addEventListener('keydown', onKey, true);
            document.addEventListener('click', onClick, true);
            if (isCorrect) {
                continueTimer = setTimeout(done, 400);
            }
        }

        async function saveTestProgress() {
            const d = testState.startTime;
            const testDateTime = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}-${String(d.getDate()).padStart(2, '0')} ${String(d.getHours()).padStart(2, '0')}:${String(d.getMinutes()).padStart(2, '0')}:${String(d.getSeconds()).padStart(2, '0')}`;
            const questionsAnswered = testState.currentIndex;
            const percentage = Math.round((testState.score / questionsAnswered) * 100);
            const testSessionId = testState.sessionId;

            SaveQueue.add('testResult', {
                saveType: 'testResult',
                testData: {
                    testDateTime,
                    setName: testState.activeSet,
                    questionsAnswered,
                    percentage,
                    testSessionId
                }
            });
        }

        async function exitTestMode() {
            if (testState && testState.currentIndex > 0) {
                await saveTestProgress().catch(e => log_('Test save failed:', e));
                const cardWidth = Object.keys(STUDY_SET_SCHEMA).length;
                const userProgress = payload.items.map(row => row.slice(cardWidth));
                await service.saveSession({
                    userId: currentCredentials.email,
                    password: currentCredentials.password,
                    activeSet: payload.activeSet,
                    saveType: 'progress',
                    data: userProgress
                }).catch(e => log_('Progress save failed:', e));
            }
            testState = null;

            // Update menu item
            const label = $('testModeLabel');
            const icon = $('testModeIcon');
            if (label) label.textContent = 'Test Mode';
            if (icon) icon.textContent = 'üß™';

            // Reset UI state
            $('quizArea').classList.remove('hidden');
            $('doneArea').classList.add('hidden');

            // Reset payload state
            if (payload && payload.state) {
                payload.state.currentIndex = -1;
            }

            goNext();
        }

        function showTestResults() {
            const percentage = Math.round((testState.score / testState.totalQuestions) * 100);

            $('quizArea').classList.add('hidden');
            $('doneArea').classList.remove('hidden');

            $('scoreText').textContent = `${testState.score}/${testState.totalQuestions} (${percentage}%)`;
            const el = $('statusBarText');
            if (el) el.textContent = 'Test Complete';

            // Hide the "study more" prompt in test mode
            const extraPrompt = $('extraNewPrompt');
            if (extraPrompt) extraPrompt.style.display = 'none';

            // Save in background
            saveTestProgress().catch(e => log_('Background test save failed:', e));
            const cardWidth = Object.keys(STUDY_SET_SCHEMA).length;
            const userProgress = payload.items.map(row => row.slice(cardWidth));
            service.saveSession({
                userId: currentCredentials.email,
                password: currentCredentials.password,
                saveType: 'progress',
                data: userProgress
            }).catch(e => log_('Background progress save failed:', e));

            testState = null;
        }

        async function loadSession() {
            log_('[loadSession] START email=' + currentCredentials.email);
            const sessionArg = {
                userId: currentCredentials.email,
                password: currentCredentials.password,
                setName: currentCredentials.activeSet || null
            };
            const sess = await service.getSession(sessionArg);
            log_('[loadSession] Received session success=' + sess.success);

            if (sess.success === false) {
                if (sess.error === 'WRONG_PASSWORD' || sess.error === 'USER_NOT_FOUND') {
                    clearCredentials();
                    showLoginModal();
                    throw new Error(sess.error);
                }
                // Handle other errors (sheet parsing, missing metadata, etc.)
                throw new Error(sess.error || 'Failed to load session');
            }

            // Merge server-provided credentials (includes global settings) into local saved credentials
            try {
                if (sess && sess.userData) {
                    const remoteCreds = sess.userData || {};
                    currentCredentials = currentCredentials || { email: sess.userId, password: currentCredentials?.password || '' };
                    // copy known keys (ThemeLight, AudioAutoPlay, PlaybackSpeed, activeSet, availableSets)
                    if (remoteCreds.ThemeLight !== undefined) currentCredentials.ThemeLight = remoteCreds.ThemeLight;
                    if (remoteCreds.AudioAutoPlay !== undefined) currentCredentials.AudioAutoPlay = remoteCreds.AudioAutoPlay;
                    if (remoteCreds.PlaybackSpeed !== undefined) currentCredentials.PlaybackSpeed = remoteCreds.PlaybackSpeed;
                    // Ensure we have defaults for any missing global keys
                    ensureGlobalDefaults(currentCredentials);
                    // persist merged credentials
                    try { localStorage.setItem('userData', JSON.stringify(currentCredentials)); } catch (e) { log_('Failed to persist merged userData', e); }
                }
            } catch (e) {
                log_('Failed to merge server credentials into local credentials:', e);
            }
            return sess;
        }

        function setupUserDisplay(sess) {
            const userIdEl = $('userIdDisplay');
            if (!userIdEl) return;
            if (sess && sess.userId) {
                userIdEl.textContent = sess.userId;
                return;
            }
            if (currentCredentials && currentCredentials.email) {
                userIdEl.textContent = currentCredentials.email;
                return;
            }
            userIdEl.textContent = '';
        }

        function populateStudySetMenu(sess) {
            const studySetList = $('studySetList');
            if (!studySetList || !Array.isArray(sess.availableSets)) return;

            studySetList.innerHTML = '';

            if (sess.availableSets.length === 0) {
                const msg = document.createElement('div');
                msg.style.padding = '12px';
                msg.style.color = '#666';
                msg.style.fontSize = '14px';
                msg.textContent = `Contact admin (${sess.adminEmail || 'administrator'}) to enable study sets`;
                studySetList.appendChild(msg);
                return;
            }

            sess.availableSets.forEach(setName => {
                const item = document.createElement('div');
                item.className = 'submenu-item';
                makeMenuItemFocusable(item);
                if (setName === sess.activeSet) item.classList.add('active');

                const label = document.createElement('span');
                label.textContent = setName;
                item.appendChild(label);

                if (setName === sess.activeSet) {
                    const check = document.createElement('span');
                    check.className = 'submenu-check';
                    check.textContent = '‚úì';
                    item.appendChild(check);
                }
                const arrow = document.createElement('span');
                arrow.className = 'menu-arrow';
                arrow.textContent = '‚ñ∂';
                item.appendChild(arrow);

                item.onclick = async () => {
                    if (setName === sess.activeSet) return;
                    if (menuDropdown) menuDropdown.hidden = true;
                    if (studySetSubmenu) studySetSubmenu.hidden = true;

                    const sb = $('statusBarText');
                    if (sb) sb.textContent = 'Switching set...';

                    // Save progress if needed
                    const saves = [];
                    if (testState && testState.currentIndex > 0) saves.push(saveTestProgress());
                    if (payload && payload.state && payload.state.answeredCount > 0) {
                        const cardWidth = Object.keys(STUDY_SET_SCHEMA).length;
                        const userProgress = payload.items.map(row => row.slice(cardWidth));
                        saves.push(service.saveSession({
                            userId: currentCredentials.email,
                            password: currentCredentials.password,
                            activeSet: payload.activeSet,
                            saveType: 'progress',
                            data: userProgress
                        }));
                    }
                    if (saves.length) await Promise.allSettled(saves);

                    // Reset state before loading new set
                    testState = null;
                    payload = null;
                    settings = [];
                    _lastSavedAnswerCount = 0;

                    // DON'T clear cache - keep all decks cached for instant switching

                    // Load new set
                    try {
                        saveCredentials(currentCredentials.email, currentCredentials.password, setName);
                        await boot();
                    } catch (err) {
                        showError_('Failed to switch set: ' + err);
                    }
                };

                studySetList.appendChild(item);
            });
        }

        function handleNoActiveSet(sess) {
            const sb = $('statusBarText');

            if (!sess.availableSets || sess.availableSets.length === 0) {
                if (sb) {
                    const adminEmail = sess.adminEmail || 'administrator';
                    sb.textContent = `Contact admin (${adminEmail}) to enable study sets`;
                }
            } else {
                if (sb) {
                    sb.textContent = 'Choose a study set from the menu (‚ò∞) to begin';
                }
            }

            $('quizArea').classList.add('hidden');
            $('doneArea').classList.add('hidden');

            const hasAvailableSets = sess.availableSets && sess.availableSets.length > 0;
            const studySetItem = $('studySetMenuItem');
            if (studySetItem) {
                if (hasAvailableSets) {
                    studySetItem.style.opacity = '';
                    studySetItem.style.pointerEvents = '';
                } else {
                    studySetItem.style.opacity = '0.5';
                    studySetItem.style.pointerEvents = 'none';
                }
            }

            ['testModeMenuItem', 'suspendMenuItem'].forEach(id => {
                const el = $(id);
                if (el) {
                    el.style.opacity = '0.5';
                    el.style.pointerEvents = 'none';
                }
            });

            const setSettingsEl = $('setSettingsOption');
            if (setSettingsEl) {
                setSettingsEl.style.opacity = '0.5';
                setSettingsEl.style.pointerEvents = 'none';
            }
        }

        function enableMenuItems(sess) {
            const hasAvailableSets = sess.availableSets && sess.availableSets.length > 0;
            const hasActiveSet = !!sess.activeSet;

            const studySetItem = $('studySetMenuItem');
            if (studySetItem) {
                if (hasAvailableSets) {
                    studySetItem.style.opacity = '';
                    studySetItem.style.pointerEvents = '';
                } else {
                    studySetItem.style.opacity = '0.5';
                    studySetItem.style.pointerEvents = 'none';
                }
            }

            ['testModeMenuItem', 'suspendMenuItem'].forEach(id => {
                const el = $(id);
                if (el) {
                    if (hasActiveSet) {
                        el.style.opacity = '';
                        el.style.pointerEvents = '';
                    } else {
                        el.style.opacity = '0.5';
                        el.style.pointerEvents = 'none';
                    }
                }
            });

            const setSettingsEl = $('setSettingsOption');
            if (setSettingsEl) {
                if (hasActiveSet) {
                    setSettingsEl.style.opacity = '';
                    setSettingsEl.style.pointerEvents = '';
                } else {
                    setSettingsEl.style.opacity = '0.5';
                    setSettingsEl.style.pointerEvents = 'none';
                }
            }
        }

        function buildPayload(sess) {
            log_('[buildPayload] Building payload from session');
            log_('[buildPayload] Received userSettings:', JSON.stringify(sess.userSettings));
            log_('[buildPayload] userSettings length:', sess.userSettings?.length);
            const items = sess.cards.map((cardRow, idx) => {
                const progressRow = sess.userProgress[idx] || [];
                return [...cardRow, ...progressRow];
            });
            log_('[buildPayload] Built ' + items.length + ' items');

            const mergedUserPrefs = (Array.isArray(sess.userPreferences) && sess.userPreferences.length)
                ? sess.userPreferences
                : (sess.userData
                    ? [
                        ['ThemeLight', (sess.userData.ThemeLight !== undefined ? sess.userData.ThemeLight : true)],
                        ['AudioAutoPlay', (sess.userData.AudioAutoPlay !== undefined ? sess.userData.AudioAutoPlay : true)],
                        ['PlaybackSpeed', (sess.userData.PlaybackSpeed !== undefined ? sess.userData.PlaybackSpeed : 1.5)]
                    ]
                    : []);

            const combinedSettings = [
                ...(Array.isArray(sess.userSettings) ? sess.userSettings : []),
                ...mergedUserPrefs
            ];

            // Determine mock-vs-server for this session using credentials or session hint
            const isMock = (typeof sess === 'object' && typeof sess._isMock === 'boolean')
                ? sess._isMock
                : (function () {
                    const mockEmail = getMockUserId();
                    const credEmail = currentCredentials && currentCredentials.email ? String(currentCredentials.email).toLowerCase() : null;
                    return mockEmail && credEmail && mockEmail === credEmail;
                })();

            const schema = !isMock
                ? (sess.studySetSchema && sess.userProgressSchema
                    ? { lexiconCols: buildLexiconSchema(sess.studySetSchema, sess.userProgressSchema) }
                    : (() => { throw new Error('Missing server schema'); })())
                : { lexiconCols: buildLexiconSchema(STUDY_SET_SCHEMA, USER_PROGRESS_SCHEMA) };

            return {
                items: items.map(r => Array.isArray(r) ? r.slice() : []),
                settings: combinedSettings.map(r => Array.isArray(r) ? r.slice() : []),
                userPreferences: mergedUserPrefs.map(r => Array.isArray(r) ? r.slice() : []),
                setSettings: sess.setSettings || {},
                activeSet: sess.activeSet || '',
                availableSets: sess.availableSets || [],
                adminEmail: sess.adminEmail || 'administrator',
                schema,
                state: {
                    currentIndex: -1,
                    answeredCount: 0,
                    servedNewToday: 0,
                    extraNewItems: 0,
                    learnedNewCount: 0,
                    learnedNewByIndex: {},
                    sessionStatusText: '',
                    _armed: false
                },
                userData: ensureGlobalDefaults(sess.userData || (function () {
                    const obj = { email: sess.userId };
                    try {
                        for (const r of mergedUserPrefs) {
                            if (!Array.isArray(r) || !r.length) continue;
                            const k = String(r[0] || '').trim();
                            if (k === 'ThemeLight' || k === 'AudioAutoPlay' || k === 'PlaybackSpeed') obj[k] = r[1];
                        }
                    } catch (e) { /* ignore */ }
                    return obj;
                })()),
                _isMock: !!isMock
            };
        }

        function getDeckCacheKey(setNameOverride = null) {
            const explicit = (setNameOverride !== null && setNameOverride !== undefined)
                ? String(setNameOverride).trim()
                : '';
            if (explicit) return explicit;
            const stored = currentCredentials && currentCredentials.activeSet
                ? String(currentCredentials.activeSet).trim()
                : '';
            // If there's no active set, return empty to signal "no cache key".
            return stored;
        }

        // IndexedDB cache: stores per-deck data
        // Structure per deck (keyed by setId):
        // {
        //   cards: [[term, image, band, def, dist1, dist2, dist3], ...],
        //   userProgress: [[due, step, reps, lapses, suspended, tags], ...],
        //   setSettings: {AudioEnabled, AudioOnly, Ladder, Lang, ...},
        //   userSettings: [['UserID', email], ['NewItemsPerDay', 4], ...],
        //   userPreferences: [['ThemeLight', true], ['AudioAutoPlay', true], ['PlaybackSpeed', 1.5]]
        // }
        const DeckCache = {
            dbName: 'fsrs_decks',
            storeName: 'studySets',
            db: null,

            async init() {
                if (this.db) {
                    // If the store is missing (old DB), rebuild.
                    if (!this.db.objectStoreNames.contains(this.storeName)) {
                        try { this.db.close(); } catch (e) { /* ignore */ }
                        await indexedDB.deleteDatabase(this.dbName);
                        this.db = null;
                    } else {
                        return this.db;
                    }
                }

                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, 1);
                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        // If the store is somehow missing, rebuild and re-init once.
                        if (!this.db.objectStoreNames.contains(this.storeName)) {
                            try { this.db.close(); } catch (e) { /* ignore */ }
                            indexedDB.deleteDatabase(this.dbName).onsuccess = () => {
                                this.db = null;
                                this.init().then(resolve).catch(reject);
                            };
                            return;
                        }
                        resolve(this.db);
                    };
                    request.onupgradeneeded = (e) => {
                        const db = e.target.result;
                        if (!db.objectStoreNames.contains(this.storeName)) {
                            db.createObjectStore(this.storeName);
                        }
                    };
                });
            },

            async get(setId) {
                try {
                    await this.init();
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction(this.storeName, 'readonly');
                        const store = tx.objectStore(this.storeName);
                        const request = store.get(setId);
                        request.onsuccess = () => resolve(request.result);
                        request.onerror = () => reject(request.error);
                    });
                } catch (e) {
                    log_('[DeckCache] get failed:', e);
                    return null;
                }
            },

            async set(setId, deckData) {
                try {
                    await this.init();
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction(this.storeName, 'readwrite');
                        const store = tx.objectStore(this.storeName);
                        const request = store.put(deckData, setId);
                        request.onsuccess = () => resolve();
                        request.onerror = () => reject(request.error);
                    });
                } catch (e) {
                    log_('[DeckCache] set failed:', e);
                }
            },

            async clearAll() {
                try {
                    await this.init();
                    return new Promise((resolve, reject) => {
                        const tx = this.db.transaction(this.storeName, 'readwrite');
                        const store = tx.objectStore(this.storeName);
                        const request = store.clear();
                        request.onsuccess = () => {
                            try {
                                this.db.close();
                            } catch (closeErr) {
                                log_('[DeckCache] close failed during clear:', closeErr);
                            }
                            this.db = null;
                            resolve();
                        };
                        request.onerror = () => reject(request.error);
                    });
                } catch (e) {
                    log_('[DeckCache] clearAll failed:', e);
                }
            }
        };

        // Helper to remove global settings from userSettings array for storage in IndexedDB.
        const GLOBAL_SETTING_NAMES = ['ThemeLight', 'AudioAutoPlay', 'PlaybackSpeed'];
        // Default values for per-user global settings persisted into localStorage.userData
        const DEFAULT_GLOBAL_SETTINGS = {
            ThemeLight: true,
            AudioAutoPlay: true,
            PlaybackSpeed: 1.5
        };

        function ensureGlobalDefaults(creds) {
            if (!creds || typeof creds !== 'object') creds = {};
            if (creds.ThemeLight === undefined) creds.ThemeLight = DEFAULT_GLOBAL_SETTINGS.ThemeLight;
            if (creds.AudioAutoPlay === undefined) creds.AudioAutoPlay = DEFAULT_GLOBAL_SETTINGS.AudioAutoPlay;
            if (creds.PlaybackSpeed === undefined || creds.PlaybackSpeed === null) creds.PlaybackSpeed = DEFAULT_GLOBAL_SETTINGS.PlaybackSpeed;
            return creds;
        }
        function stripGlobalSettingsFromArray(arr) {
            if (!Array.isArray(arr)) return [];
            try {
                return arr.filter(r => !(Array.isArray(r) && GLOBAL_SETTING_NAMES.includes(String(r[0]))));
            } catch (e) { return arr; }
        }

        function buildCachedSession(deckData, cacheKeyHint = '') {
            const meta = loadUserMetadata();
            const activeSetName = (meta && meta.activeSet)
                ? meta.activeSet
                : (cacheKeyHint || currentCredentials?.activeSet || '');
            return {
                activeSet: activeSetName,
                availableSets: Array.isArray(meta?.availableSets) ? meta.availableSets.slice() : [],
                // do not persist adminEmail in cached session; use server-provided value when available
                cards: Array.isArray(deckData?.cards) ? deckData.cards : [],
                userSettings: Array.isArray(deckData?.userSettings) ? stripGlobalSettingsFromArray(deckData.userSettings) : [],
                // Global preferences come from localStorage.userData/currentCredentials (single source of truth)
                userPreferences: [],
                userData: (function () {
                    if (deckData && deckData.userData) return ensureGlobalDefaults(deckData.userData);
                    if (currentCredentials) return ensureGlobalDefaults({ email: currentCredentials.email, ThemeLight: currentCredentials.ThemeLight, AudioAutoPlay: currentCredentials.AudioAutoPlay, PlaybackSpeed: currentCredentials.PlaybackSpeed });
                    return null;
                })(),
                userProgress: Array.isArray(deckData?.userProgress) ? deckData.userProgress : [],
                setSettings: deckData?.setSettings || {},
                studySetSchema: STUDY_SET_SCHEMA,
                userProgressSchema: USER_PROGRESS_SCHEMA
            };
        }



        async function clearClientStorage() {
            SaveQueue.clear();
            try {
                await DeckCache.clearAll();
            } catch (e) {
                log_('[clearClientStorage] failed to wipe cache:', e);
            }
            clearUserMetadataStorage();
            localStorage.clear();
        }

        async function boot(cachedSession = null) {
            const t0 = performance.now();
            log_('[boot] START');

            if (!currentCredentials || !currentCredentials.email || !currentCredentials.password) {
                log_('[boot] No credentials, showing login');
                showLoginModal();
                return;
            }
            log_('[boot] Has credentials, loading session');

            const sb = $('statusBarText');
            if (sb) sb.textContent = 'Loading...';

            // Try IndexedDB cache first
            const cacheKey = getDeckCacheKey();
            let cachedDeckData = null;
            let cachedSess = null;

            if (!cachedSession) {
                try {
                    if (cacheKey) {
                        cachedDeckData = await DeckCache.get(cacheKey);
                    }
                    if (cachedDeckData) {
                        cachedSess = buildCachedSession(cachedDeckData, cacheKey);
                        log_('[boot] Found cached session in IndexedDB, using immediately');
                        // Merge cached userData into local credentials so theme/audio can apply early
                        try {
                            if (cachedSess.userData) {
                                currentCredentials = currentCredentials || {};
                                if (cachedSess.userData.email) currentCredentials.email = cachedSess.userData.email;
                                if (cachedSess.userData.ThemeLight !== undefined) currentCredentials.ThemeLight = cachedSess.userData.ThemeLight;
                                if (cachedSess.userData.AudioAutoPlay !== undefined) currentCredentials.AudioAutoPlay = cachedSess.userData.AudioAutoPlay;
                                if (cachedSess.userData.PlaybackSpeed !== undefined) currentCredentials.PlaybackSpeed = cachedSess.userData.PlaybackSpeed;
                                try { ensureGlobalDefaults(currentCredentials); localStorage.setItem('userData', JSON.stringify(currentCredentials)); } catch (e) { log_('Failed to persist cached userData', e); }
                            }
                        } catch (e) { /* ignore */ }
                        if (sb) sb.textContent = 'Loading cached data...';
                        // Apply theme & audio state immediately using cached credentials
                        try { applyTheme(); initAudioStateFromSettings(); } catch (e) { /* ignore */ }
                    }
                } catch (e) {
                    log_('[boot] Cache read failed:', e);
                }
            }

            try {
                // If we have cached data, show it immediately (only when it has an active set)
                if (cachedSess) {
                    if (currentCredentials && cachedSess.activeSet && currentCredentials.activeSet !== cachedSess.activeSet) {
                        saveCredentials(currentCredentials.email, currentCredentials.password, cachedSess.activeSet);
                    }
                    setupUserDisplay(cachedSess);
                    populateStudySetMenu(cachedSess);

                    if (!cachedSess.activeSet) {
                        handleNoActiveSet(cachedSess);
                        // still fetch fresh data below, but skip rendering settings/cards without an active set
                    } else {
                        enableMenuItems(cachedSess);

                        if (!Array.isArray(cachedSess.cards) || !Array.isArray(cachedSess.userProgress)) {
                            throw new Error('Cached session is invalid');
                        }

                        payload = buildPayload(cachedSess);
                        settings = payload.settings.map(r => Array.isArray(r) ? r.slice() : []);
                        userPreferences = payload.userPreferences ? payload.userPreferences.map(r => Array.isArray(r) ? r.slice() : []) : [];

                        // Persisted daily cap: ensure keys exist and reset on day rollover.
                        normalizeDailyNewCap_({ persist: true });

                        renderSettingsUI({ settings });
                        // Preview the theme using the draft (if available) rather than current stored value
                        try {
                            // Save the current applied theme for potential revert
                            _themePreviewOriginal = (function () {
                                try { return getSetting(THEME_SETTING_NAME); } catch (e) { return currentCredentials?.ThemeLight; }
                            })();
                            const themeRow = (settingsDraft || []).find(r => Array.isArray(r) && String(r[0]) === 'ThemeLight');
                            applyTheme(themeRow ? themeRow[1] : undefined);
                        } catch (e) { _themePreviewOriginal = (document.body && document.body.dataset && document.body.dataset.theme === 'light'); applyTheme(); }
                        autoAdjustNewItemsPerDay();

                        $('quizArea').classList.remove('hidden');
                        $('doneArea').classList.add('hidden');
                        initAudioStateFromSettings();

                        log_('[boot] Cached data displayed, fetching fresh in background');
                        if (sb) sb.textContent = 'Syncing...';
                        goNext();
                    }
                }

                // Always fetch fresh data in background
                const sess = cachedSession || (log_('boot: calling service.getSession()'), await loadSession());

                if (sess && typeof sess === 'object') {
                    if (currentCredentials && sess.activeSet && currentCredentials.activeSet !== sess.activeSet) {
                        saveCredentials(currentCredentials.email, currentCredentials.password, sess.activeSet);
                    }
                    // Persist only activeSet & availableSets; keep adminEmail in-memory only
                    saveUserMetadata({
                        activeSet: sess.activeSet,
                        availableSets: sess.availableSets
                    });
                    // Update in-memory adminEmail value for UI display, do not persist it
                    try { currentUserMetadata = currentUserMetadata || { activeSet: '', availableSets: [], adminEmail: 'administrator' }; currentUserMetadata.adminEmail = sess.adminEmail || currentUserMetadata.adminEmail || 'administrator'; } catch (e) { /* ignore */ }
                }

                // Display retry info if present
                if (sess.retryInfo) {
                    log_('[boot] ' + sess.retryInfo);
                }
                if (frontendRetryCount > 0) {
                    log_(`[boot] Frontend retried ${frontendRetryCount} request(s)`);
                    frontendRetryCount = 0;
                }

                // Update cache with fresh data (IndexedDB)
                const freshKey = getDeckCacheKey(sess.activeSet);
                const deckDataForCache = {
                    cards: Array.isArray(sess.cards) ? sess.cards.map(r => Array.isArray(r) ? r.slice() : []) : [],
                    userSettings: Array.isArray(sess.userSettings) ? stripGlobalSettingsFromArray(sess.userSettings.map(r => Array.isArray(r) ? r.slice() : [])) : [],
                    userProgress: Array.isArray(sess.userProgress) ? sess.userProgress.map(r => Array.isArray(r) ? r.slice() : []) : [],
                    setSettings: sess.setSettings || {},
                    // userData intentionally not persisted to IndexedDB (global user settings are volatile/local)
                };
                if (freshKey) {
                    DeckCache.set(freshKey, deckDataForCache).catch(e => log_('[boot] Cache write failed:', e));
                }
                log_('[boot] Cache updated with fresh data');

                // If we already showed cached data, check if anything changed
                if (cachedDeckData) {
                    const progressChanged = JSON.stringify(cachedDeckData.userProgress) !== JSON.stringify(sess.userProgress);
                    const settingsChanged = JSON.stringify(cachedDeckData.userSettings) !== JSON.stringify(stripGlobalSettingsFromArray(sess.userSettings || []));
                    if (progressChanged || settingsChanged) {
                        log_('[boot] Data changed (progress=' + progressChanged + ', settings=' + settingsChanged + '), updating UI');
                        if (sb) sb.textContent = 'Updated from server';

                        // Rebuild payload with fresh data
                        payload = buildPayload(sess);
                        settings = payload.settings.map(r => Array.isArray(r) ? r.slice() : []);
                        userPreferences = payload.userPreferences ? payload.userPreferences.map(r => Array.isArray(r) ? r.slice() : []) : [];

                        // Persisted daily cap: ensure keys exist and reset on day rollover.
                        normalizeDailyNewCap_({ persist: true });

                        renderSettingsUI({ settings });
                        applyTheme();
                        autoAdjustNewItemsPerDay();

                        // Reset to first card with fresh data
                        payload.state.currentIndex = -1;
                        goNext();
                    } else {
                        log_('[boot] No changes detected');
                        if (sb) updateSessionStats();
                    }
                    return;
                }

                // No cached data - show fresh data normally
                setupUserDisplay(sess);
                populateStudySetMenu(sess);

                if (!sess.activeSet) {
                    handleNoActiveSet(sess);
                    return;
                }

                enableMenuItems(sess);

                if (!Array.isArray(sess.cards) || !Array.isArray(sess.userProgress)) {
                    log_('Session validation failed:', sess);
                    throw new Error('Session is missing cards/userProgress');
                }

                payload = buildPayload(sess);
                log_('[boot] Payload built, items=' + payload.items.length);
                log_('[boot] Payload.settings:', JSON.stringify(payload.settings));

                // Active settings (editable copy for this run)
                settings = payload.settings.map(r => Array.isArray(r) ? r.slice() : []);
                userPreferences = payload.userPreferences ? payload.userPreferences.map(r => Array.isArray(r) ? r.slice() : []) : [];
                log_('[boot] Active settings copied, length=' + settings.length);
                log_('[boot] Active settings:', JSON.stringify(settings));

                // Persisted daily cap: ensure keys exist and reset on day rollover.
                normalizeDailyNewCap_({ persist: true });

                renderSettingsUI({ settings });
                applyTheme();
                autoAdjustNewItemsPerDay();
                log_('[boot] UI initialized');

                // UI show
                $('quizArea').classList.remove('hidden');
                $('doneArea').classList.add('hidden');

                // Autoplay arming (once)
                initAudioStateFromSettings();
                log_('[boot] SUCCESS ' + Math.round(performance.now() - t0) + 'ms');
                if (!cachedSess) goNext();
            } catch (err) {
                log_('boot: caught error', err);
                log_('boot: error stack', err.stack);
                // Decide mock fallback using credentials only (no global IS_MOCK)
                const isMock = (currentCredentials && currentCredentials.email)
                    ? (function () { const mockEmail = getMockUserId(); return mockEmail && String(currentCredentials.email).toLowerCase() === mockEmail; })()
                    : false;
                if (!isMock) {
                    showError_('Failed to load session from server: ' + (err.message || String(err)));
                    return;
                }
                // Mock fallback
                payload = {
                    items: MOCK_ITEMS.map(r => r.slice()),
                    settings: [...MOCK_DECK_USER_SETTINGS, ...MOCK_USER_PREFERENCES].map(r => Array.isArray(r) ? r.slice() : []),
                    userPreferences: MOCK_USER_PREFERENCES.map(r => Array.isArray(r) ? r.slice() : []),
                    setSettings: MOCK_SET_SETTINGS,
                    activeSet: 'TestSet',
                    schema: { lexiconCols: buildLexiconSchema(STUDY_SET_SCHEMA, USER_PROGRESS_SCHEMA) },
                    state: {
                        currentIndex: -1,
                        answeredCount: 0,
                        servedNewToday: 0,
                        extraNewItems: 0,
                        learnedNewCount: 0,
                        learnedNewByIndex: {},
                        learnedNewCount: 0,
                        learnedNewByIndex: {},
                        sessionStatusText: '',
                        _armed: false
                    },
                    _isMock: true
                };
                settings = payload.settings.map(r => Array.isArray(r) ? r.slice() : []);
                userPreferences = payload.userPreferences ? payload.userPreferences.map(r => Array.isArray(r) ? r.slice() : []) : [];

                // Persisted daily cap (mock): ensure keys exist/reset; do not persist.
                normalizeDailyNewCap_({ persist: false });

                renderSettingsUI({ settings });
                applyTheme();
                $('quizArea').classList.remove('hidden');
                $('doneArea').classList.add('hidden');
                initAudioStateFromSettings();
                log_(`[FRONT] boot(mock) ${Math.round(performance.now() - t0)}ms`);
                goNext();
            }
        }

        function decideNextIndex() {
            log_('[decideNextIndex] Finding next card');
            const C = payload.schema.lexiconCols;
            const baseNewLimit = getSetting('NewItemsPerDay', true);
            const extraNew = Number(payload?.state?.extraNewItems || 0);
            const limitNew = baseNewLimit + (Number.isFinite(extraNew) ? extraNew : 0);
            const now = Date.now();
            const items = payload.items;
            const dailyLearned = Number(getSettingSafe_('DailyNewCount', 0, true) || 0);
            log_('[decideNextIndex] limitNew=' + limitNew + ' dailyLearned=' + dailyLearned);

            for (let i = 0; i < items.length; i++) {
                const row = items[i];
                if (!row) continue;
                const suspended = !!row[C.suspended];
                const reps = Number(row[C.reps] || 0);
                const step = Number(row[C.step] || 0);
                const due = parseDue_(row[C.due]);
                const isNew = (reps === 0 && step === 0 && !(due instanceof Date));
                if (!suspended && isNew && dailyLearned < limitNew) {
                    log_('[decideNextIndex] Found new card at index ' + i);
                    return i;
                }
            }

            // Review selection:
            // Choose the earliest due time among all cards due within the ReviewAhead window.
            // ReviewAhead is implemented as "allow scheduling up to MIN_REVIEW_INTERVAL_MS early".
            // This is just a shift; selection is still by earliest due.

            const reviewAheadUntil = now + MIN_REVIEW_INTERVAL_MS;
            let earliestIndex = -1;
            let earliestTime = Number.POSITIVE_INFINITY;

            for (let i = 0; i < items.length; i++) {
                const row = items[i];
                if (!row) continue;
                if (row[C.suspended]) continue;

                const due = parseDue_(row[C.due]);
                if (!(due instanceof Date)) continue;
                const dueMs = due.getTime();
                if (!Number.isFinite(dueMs)) continue;

                if (dueMs <= reviewAheadUntil && dueMs < earliestTime) {
                    earliestTime = dueMs;
                    earliestIndex = i;
                }
            }

            log_('[decideNextIndex] Result index=' + earliestIndex);
            return earliestIndex;
        }

        function getDistractorColumnIndices() {
            const schema = payload?.schema?.lexiconCols || buildLexiconSchema(STUDY_SET_SCHEMA, USER_PROGRESS_SCHEMA);
            return DISTRACTOR_KEYS
                .map(key => schema[key])
                .filter(idx => Number.isFinite(idx));
        }

        function computeOptionsForRow(rowIndex) {
            const distractorIndices = getDistractorColumnIndices();
            const totalDistractors = distractorIndices.length;
            if (!totalDistractors) return { options: [], correctIndex: null };
            const C = payload.schema.lexiconCols || buildLexiconSchema(STUDY_SET_SCHEMA, USER_PROGRESS_SCHEMA);
            const defCol = C.definition;
            const row = payload.items[rowIndex] || [];
            const correctText = String(row[defCol] ?? '').trim();
            if (!correctText) return { options: [], correctIndex: null };

            const useReferences = (() => {
                try {
                    const setSettings = payload?.setSettings || MOCK_SET_SETTINGS || {};
                    const val = setSettings.DistractorsAsReference;
                    return val === true || val === 'true' || val === 'TRUE';
                } catch (e) {
                    return false;
                }
            })();

            if (useReferences) {
                const dataStartRow = Number(payload?.setSettings?.DATA_START_ROW) || 1;
                const distRows = distractorIndices.map(idx => {
                    const ref = Number(row[idx]);
                    if (!Number.isFinite(ref) || ref < dataStartRow) return -1;
                    return ref - dataStartRow;
                }).filter(i => i >= 0 && i < payload.items.length && i !== rowIndex);
                const required = totalDistractors;
                const chosen = [];
                const seenDefs = new Set();
                seenDefs.add(correctText.toLowerCase());
                for (let i = 0; i < distRows.length && chosen.length < required; i++) {
                    const candRow = payload.items[distRows[i]] || [];
                    const candText = String(candRow[defCol] ?? '').trim();
                    if (!candText) continue;
                    if (seenDefs.has(candText.toLowerCase())) continue;
                    seenDefs.add(candText.toLowerCase());
                    chosen.push(candText);
                }
                if (chosen.length < required) {
                    return { options: [], correctIndex: null };
                }
                const options = [correctText, ...chosen].map(text => ({ text }));
                const enumerated = options.map((opt, idx) => ({ ...opt, originalIndex: idx }));
                const shuffled = enumerated.sort(() => Math.random() - 0.5);
                const correctIndex = shuffled.findIndex(opt => opt.originalIndex === 0);
                return {
                    options: shuffled.map(opt => opt.text),
                    correctIndex
                };
            }

            // Non-reference mode: read literal text from distractor columns
            const texts = [];
            for (const idx of distractorIndices) {
                const value = String(row[idx] ?? '').trim();
                if (!value) return { options: [], correctIndex: null };
                texts.push(value);
            }
            // Correct answer is always definition column, distractors are literal text
            const options = [correctText, ...texts].map(text => ({ text }));
            const enumerated = options.map((opt, idx) => ({ ...opt, originalIndex: idx }));
            const shuffled = enumerated.sort(() => Math.random() - 0.5);
            const correctIndex = shuffled.findIndex(opt => opt.originalIndex === 0);
            return {
                options: shuffled.map(opt => opt.text),
                correctIndex
            };
        }

        function suspendCurrentCard() {
            const C = payload.schema.lexiconCols;
            const currentIndex = payload.state.currentIndex;
            if (currentIndex < 0 || currentIndex >= payload.items.length) return;

            const row = payload.items[currentIndex];
            row[C.suspended] = true;

            // In study mode, autosave will handle persistence
            // Skip to next card immediately
            goNext();
        }

        function populateSuspendBands() {
            if (!payload || !payload.items) return;

            const C = payload.schema.lexiconCols;
            const bandList = $('suspendBandList');
            if (!bandList) return;

            // Collect unique bands
            const bandCounts = {};
            for (const row of payload.items) {
                const band = String(row[C.band] || '').trim() || 'No Band';
                bandCounts[band] = (bandCounts[band] || 0) + 1;
            }

            const bands = Object.keys(bandCounts).sort();
            bandList.innerHTML = '';

            // If only one band or no bands, open directly
            if (bands.length <= 1) {
                openSuspendModal(null);
                return;
            }

            // Create submenu items for each band
            bands.forEach(band => {
                const item = document.createElement('div');
                item.className = 'submenu-item';
                makeMenuItemFocusable(item);
                const label = document.createElement('span');
                label.textContent = `${band} (${bandCounts[band]})`;
                item.appendChild(label);
                const arrow = document.createElement('span');
                arrow.className = 'menu-arrow';
                arrow.textContent = '‚ñ∂';
                item.appendChild(arrow);
                item.onclick = () => {
                    if (menuDropdown) menuDropdown.hidden = true;
                    if (suspendSubmenu) suspendSubmenu.hidden = true;
                    openSuspendModal(band === 'No Band' ? '' : band);
                };
                bandList.appendChild(item);
            });

            // Add "All Cards" option
            const allItem = document.createElement('div');
            allItem.className = 'submenu-item';
            makeMenuItemFocusable(allItem);
            const allLabel = document.createElement('span');
            allLabel.textContent = `All Cards (${payload.items.length})`;
            allItem.appendChild(allLabel);
            const allArrow = document.createElement('span');
            allArrow.className = 'menu-arrow';
            allArrow.textContent = '‚ñ∂';
            allItem.appendChild(allArrow);
            allItem.onclick = () => {
                if (menuDropdown) menuDropdown.hidden = true;
                if (suspendSubmenu) suspendSubmenu.hidden = true;
                openSuspendModal(null);
            };
            bandList.appendChild(allItem);
        }

        function openSuspendModal(bandFilter) {
            if (!payload || !payload.items) return;

            const C = payload.schema.lexiconCols;
            const modal = $('suspendModal');
            const title = $('suspendModalTitle');
            const cardList = $('suspendCardList');
            const searchInput = $('suspendSearch');

            if (!modal || !cardList) return;

            if (title) {
                title.textContent = bandFilter ? `Suspend Cards - ${bandFilter}` : 'Suspend Cards - All';
            }

            const filteredCards = [];
            for (let i = 0; i < payload.items.length; i++) {
                const row = payload.items[i];
                const band = String(row[C.band] || '').trim();
                if (bandFilter === null || band === bandFilter) {
                    filteredCards.push({ index: i, row });
                }
            }

            const renderCardList = (searchTerm = '') => {
                cardList.innerHTML = '';
                const term = searchTerm.toLowerCase();

                const highlight = (text) => {
                    if (!term) return text;
                    const regex = new RegExp(`(${term.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                    return text.replace(regex, '<mark style="background: #ffeb3b; padding: 0 2px;">$1</mark>');
                };

                filteredCards.forEach(({ index, row }) => {
                    const cardTerm = String(row[C.term] || '').trim();
                    const cardDef = String(row[C.definition] || '').trim();
                    const combined = `${cardTerm} ${cardDef}`.toLowerCase();

                    if (term && !combined.includes(term)) return;

                    const isSuspended = !!row[C.suspended];

                    const item = document.createElement('div');
                    item.style.display = 'grid';
                    item.style.gridTemplateColumns = 'auto 1fr 1fr';
                    item.style.gap = '12px';
                    item.style.padding = '8px';
                    item.style.borderBottom = '1px solid #eee';
                    item.style.alignItems = 'center';

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.checked = isSuspended;
                    checkbox.dataset.index = index;
                    checkbox.style.cursor = 'pointer';

                    const termSpan = document.createElement('span');
                    termSpan.innerHTML = highlight(cardTerm);
                    termSpan.setAttribute('dir', 'auto');
                    if (isSuspended) {
                        termSpan.style.textDecoration = 'line-through';
                        termSpan.style.opacity = '0.5';
                    }

                    const defSpan = document.createElement('span');
                    defSpan.innerHTML = highlight(cardDef);
                    defSpan.setAttribute('dir', 'auto');
                    if (isSuspended) {
                        defSpan.style.textDecoration = 'line-through';
                        defSpan.style.opacity = '0.5';
                    }

                    checkbox.onchange = () => {
                        const isChecked = checkbox.checked;
                        termSpan.style.textDecoration = isChecked ? 'line-through' : 'none';
                        termSpan.style.opacity = isChecked ? '0.5' : '1';
                        defSpan.style.textDecoration = isChecked ? 'line-through' : 'none';
                        defSpan.style.opacity = isChecked ? '0.5' : '1';
                    }

                    item.appendChild(checkbox);
                    item.appendChild(termSpan);
                    item.appendChild(defSpan);
                    cardList.appendChild(item);
                });
            };

            renderCardList();

            if (searchInput) {
                searchInput.value = '';
                searchInput.oninput = () => renderCardList(searchInput.value);
            }

            modal.hidden = false;
        }

        function stopAudio() {
            _audioRequestId++;
            const audio = _audioEl || initAudioElement();
            try {
                audio.pause();
                audio.currentTime = 0;
            } catch (e) { }
        }

        function determineQuestionMode(currentIndex) {
            const expectedDistractors = getDistractorColumnIndices().length;
            let preferMCQ = false;
            try {
                const val = getSetting('QuizMode');
                preferMCQ = (val === true || val === 'true');
            } catch (e) {
                preferMCQ = true;
            }
            let effectiveMode = preferMCQ ? 'MultipleChoice' : 'FlashCard';
            let optionsBundle = { options: [], correctIndex: null };

            if (effectiveMode === 'MultipleChoice') {
                optionsBundle = computeOptionsForRow(currentIndex);
                const expectedOptions = expectedDistractors + 1; // distractors + correct answer
                if (!expectedDistractors || optionsBundle.options.length < expectedOptions || optionsBundle.correctIndex === null) {
                    effectiveMode = 'FlashCard';
                    optionsBundle = { options: [], correctIndex: null };
                }
            }
            return { effectiveMode, optionsBundle };
        }

        function setupAudioForRow(row, isAudioOnly) {
            try {
                _currentAudioUrl = resolveAudioUrlForRow(row);
                const hasAudio = !!_currentAudioUrl;
                const audioBtn = $('audioBtn');
                const qEl = $('termText');

                if (audioBtn) audioBtn.classList.remove('audio-only-mode');

                if (isAudioOnly && hasAudio) {
                    if (qEl) qEl.style.display = 'none';
                    if (audioBtn) audioBtn.classList.add('audio-only-mode');
                    _audioEnabled = true;
                    log_('[Audio] AudioOnly mode, URL:', _currentAudioUrl);
                } else {
                    if (qEl) qEl.style.display = '';
                }

                updateAudioUIForCurrentRow(hasAudio);

                if (hasAudio && _audioEnabled) {
                    log_('[Audio] Auto-playing...');
                    playAudioUrl(_currentAudioUrl).then(success => {
                        log_('[Audio] Auto-play result:', success);
                    });
                }
            } catch (e) {
                log_('[Audio] Setup error:', e);
                const audioBtn = $('audioBtn');
                if (audioBtn) { audioBtn.hidden = false; audioBtn.disabled = true; }
            }
        }

        function setupImageForRow(row, term) {
            const C = payload.schema.lexiconCols;
            const imageWrap = $('termImageWrap');
            const imageEl = $('termImage');
            const imageUrl = String(row[C.image] ?? '').trim();
            if (imageEl && imageUrl) {
                imageWrap?.classList.remove('active');
                imageEl.onload = () => {
                    imageWrap?.classList.add('active');
                    autoshrinkAll();
                };
                imageEl.onerror = () => autoshrinkAll();
                imageEl.src = imageUrl;
                imageEl.alt = term;
            } else {
                if (imageEl) imageEl.removeAttribute('src');
                imageWrap?.classList.remove('active');
            }
        }

        function renderMCQOptions(optionsBundle) {
            const answersEl = $('answers');
            const options = optionsBundle.options;
            answersEl.dataset.count = String(options.length || 0);
            const correctIndex = optionsBundle.correctIndex ?? -1;
            for (let i = 0; i < options.length; i++) {
                const btn = document.createElement('button');
                btn.className = 'answer';
                const span = document.createElement('span');
                span.className = 'answer-label';
                span.setAttribute('dir', 'auto');
                span.textContent = options[i] || '';
                btn.appendChild(span);
                btn.onclick = () => onAnswer(i, correctIndex);
                answersEl.appendChild(btn);
            }
        }

        function renderFlashCard(term, def) {
            const answersEl = $('answers');
            const wrap = document.createElement('div');
            wrap.className = 'flash-wrap';
            const card = document.createElement('div');
            card.className = 'flip-card';
            const inner = document.createElement('div');
            inner.className = 'flip-inner';
            const front = document.createElement('div');
            front.className = 'flip-face flip-front';
            front.setAttribute('dir', 'auto');
            front.textContent = term;
            const back = document.createElement('div');
            back.className = 'flip-face flip-back';
            back.setAttribute('dir', 'auto');
            back.textContent = def;
            inner.appendChild(front);
            inner.appendChild(back);
            card.appendChild(inner);
            wrap.appendChild(card);

            const controls = document.createElement('div');
            controls.className = 'flash-controls';
            controls.hidden = true;

            const okBtn = document.createElement('button');
            okBtn.type = 'button';
            okBtn.className = 'fc-btn correct';
            okBtn.textContent = '‚úì Correct';
            okBtn.disabled = true;

            const noBtn = document.createElement('button');
            noBtn.type = 'button';
            noBtn.className = 'fc-btn wrong';
            noBtn.textContent = '‚úó Wrong';
            noBtn.disabled = true;

            const FLASH_CORRECT = 0;
            okBtn.addEventListener('click', () => onAnswer(FLASH_CORRECT, FLASH_CORRECT));
            noBtn.addEventListener('click', () => onAnswer(-1, FLASH_CORRECT));

            controls.appendChild(okBtn);
            controls.appendChild(noBtn);

            answersEl.appendChild(wrap);
            answersEl.appendChild(controls);

            let firstRevealDone = false;
            const onFlip = () => {
                const wasFlipped = card.classList.contains('is-flipped');
                card.classList.toggle('is-flipped');

                if (!wasFlipped && !firstRevealDone) {
                    controls.hidden = false;
                    okBtn.disabled = false;
                    noBtn.disabled = false;
                    firstRevealDone = true;
                }
            };
            card.addEventListener('click', onFlip);
            setTimeout(() => autoshrinkAll(), 0);
        }

        function renderTerm() {
            stopAudio();

            const C = payload.schema.lexiconCols;
            const currentIndex = payload.state.currentIndex;
            const row = payload.items[currentIndex];

            const isAudioOnly = payload?.setSettings?.AudioOnly === true || payload?.setSettings?.AudioOnly === 'true';
            const term = String(row[C.term]);
            const def = String(row[C.definition]);

            const { effectiveMode, optionsBundle } = determineQuestionMode(currentIndex);

            const isMCQ = (effectiveMode === 'MultipleChoice');
            const termHeader = $('termHeader');
            const qEl = $('termText');
            const suspendBtn = $('suspendBtn');
            const answersEl = $('answers');

            if (suspendBtn) {
                suspendBtn.hidden = false;
                suspendBtn.onclick = () => {
                    showConfirm('Suspend this card? It will be hidden from study and tests.', () => {
                        if (wasNewBeforeAnswer && payload.state.servedNewToday > 0) {
                            payload.state.servedNewToday--;
                        }
                        wasNewBeforeAnswer = false;
                        suspendCurrentCard();
                    });
                };
            }

            setupAudioForRow(row, isAudioOnly);
            setupImageForRow(row, term);

            setFeedback_('');
            answersEl.innerHTML = '';
            answersEl.classList.toggle('is-flash', !isMCQ);

            if (isMCQ) {
                termHeader?.removeAttribute('data-hide');
                qEl.classList.add('autoshrink');
                qEl.textContent = term;
                renderMCQOptions(optionsBundle);
            } else {
                delete answersEl.dataset.count;
                termHeader?.removeAttribute('data-hide');
                qEl.classList.add('autoshrink');
                qEl.textContent = term;
                renderFlashCard(term, def);
            }
            setTimeout(() => {
                qEl.classList.add('autoshrink');
                autoshrinkAll();
            }, 0);
        }

        let wasNewBeforeAnswer = false;

        function updateCardSchedule(row, isCorrect) {
            const C = payload.schema.lexiconCols;
            const setSettings = payload?.setSettings || MOCK_SET_SETTINGS || {};
            const ladder = getEffectiveDeckLadder_(setSettings);
            const now = Date.now();
            const step0 = Number(row[C.step] || 0);
            const reps0 = Number(row[C.reps] || 0);
            const lapses0 = Number(row[C.lapses] || 0);
            const stepIdx0 = Math.max(0, Math.min(Number.isFinite(step0) ? step0 : 0, ladder.length - 1));
            const denom = ladder[stepIdx0] || 1;
            const due = parseDue_(row[C.due]);

            let step = stepIdx0;
            let reps = Number.isFinite(reps0) ? reps0 : 0;
            let lapses = Number.isFinite(lapses0) ? lapses0 : 0;

            if (isCorrect) {
                step = Math.min(step + 1, ladder.length - 1);
            } else {
                step = 0;
                lapses++;
            }
            reps++;

            row[C.step] = step;
            row[C.reps] = reps;
            row[C.lapses] = lapses;

            const Inext = ladder[step] || 0;
            const delay = (due > 0) ? (now - due) / 86400000 : 0;
            const scale = Math.min(2, Math.max(0.5, 1 + 0.3 * (delay / denom)));
            const nextDue = new Date(now + Inext * scale * 86400000);

            // Store due consistently as "YYYY-MM-DD HH:MM:SS" (local time).
            // This matches Apps Script's sanitize2DArray_ format for Date cells.
            const pad2 = (n) => String(n).padStart(2, '0');
            const yyyy = nextDue.getFullYear();
            const mm = pad2(nextDue.getMonth() + 1);
            const dd = pad2(nextDue.getDate());
            const hh = pad2(nextDue.getHours());
            const mi = pad2(nextDue.getMinutes());
            const ss = pad2(nextDue.getSeconds());
            row[C.due] = `${yyyy}-${mm}-${dd} ${hh}:${mi}:${ss}`;
        }

        function onAnswer(chosenIndex, correctIndex) {
            log_('[onAnswer] chosen=' + chosenIndex + ' correct=' + correctIndex);
            const C = payload.schema.lexiconCols;
            const isCorrect = chosenIndex === correctIndex;
            const row = payload.items[payload.state.currentIndex];

            // Note: sheet values may come as strings (e.g., "0"), so normalize to numbers.
            const reps0 = Number(row[C.reps] || 0);
            const step0 = Number(row[C.step] || 0);
            const due0 = parseDue_(row[C.due]);
            wasNewBeforeAnswer = (reps0 === 0 && step0 === 0 && !(due0 instanceof Date));

            // Session accounting:
            // - servedNewToday: legacy (selection now uses persisted DailyNewCount)
            // - learnedNewCount: session-only (used to bump Review immediately after learning)
            // - DailyNewCount: persisted daily cap counter (deck setting; survives reloads)
            if (wasNewBeforeAnswer) {
                payload.state.servedNewToday = Number(payload.state.servedNewToday || 0) + 1;
                if (isCorrect) {
                    const idx = Number(payload.state.currentIndex);
                    payload.state.learnedNewByIndex = (payload.state.learnedNewByIndex && typeof payload.state.learnedNewByIndex === 'object')
                        ? payload.state.learnedNewByIndex
                        : {};
                    if (Number.isFinite(idx) && !payload.state.learnedNewByIndex[idx]) {
                        payload.state.learnedNewByIndex[idx] = true;
                        payload.state.learnedNewCount = Number(payload.state.learnedNewCount || 0) + 1;

                        // Persisted daily cap: increment DailyNewCount for today's day-key.
                        try {
                            normalizeDailyNewCap_({ persist: false });
                            const todayKey = getLocalDayKey_();
                            const currentDaily = Number(getSettingSafe_('DailyNewCount', 0, true) || 0);
                            const nextDaily = (Number.isFinite(currentDaily) ? currentDaily : 0) + 1;
                            const allowGrow = !!payload?._isMock;

                            const okDay1 = setMatrixValueFixed_(settings, 'DailyNewDayKey', todayKey, { allowGrow });
                            const okCnt1 = setMatrixValueFixed_(settings, 'DailyNewCount', nextDaily, { allowGrow });
                            if (Array.isArray(payload.settings)) {
                                setMatrixValueFixed_(payload.settings, 'DailyNewDayKey', todayKey, { allowGrow });
                                setMatrixValueFixed_(payload.settings, 'DailyNewCount', nextDaily, { allowGrow });
                            }

                            if (!payload?._isMock) {
                                if (okDay1 && okCnt1) {
                                    markDailyCapDirty_();
                                } else {
                                    showToast('Daily cap cannot persist: add 2 empty deck settings rows', 'error');
                                }
                            }
                        } catch (e) {
                            log_('[DailyCap] Failed to increment DailyNewCount:', e);
                        }
                    }
                }
            }

            updateCardSchedule(row, isCorrect);
            try {
                const idx = payload.state.currentIndex;
                const term = (C && C.term !== undefined) ? String(row[C.term] ?? '') : '';
                log_(`[schedule] idx=${idx} correct=${isCorrect} step=${row[C.step]} reps=${row[C.reps]} lapses=${row[C.lapses]} nextDue=${row[C.due]} term=${term}`);
            } catch (e) {
                // logging only
            }
            payload.state.answeredCount++;
            log_('[onAnswer] answeredCount=' + payload.state.answeredCount);
            try { markProgressDirty_(); } catch (e) { }
            maybeAutosave_();
            showFeedback_(chosenIndex, correctIndex);
        }

        function showFeedback_(chosenIndex, correctIndex) {
            const isMCQ = !!document.querySelector('.answer');       // MCQ present?
            const flipCard = document.querySelector('.flip-card');    // Flash present?
            const okBtn = document.querySelector('.fc-btn.correct');
            const noBtn = document.querySelector('.fc-btn.wrong');

            // MCQ visuals (unchanged)
            const btns = Array.from(document.querySelectorAll('.answer'));
            btns.forEach(b => b.classList.remove('correct', 'wrong', 'selected-wrong'));

            const isCorrect = (chosenIndex === correctIndex);

            if (isCorrect) {
                setFeedback_('<span class="success">‚úì Correct</span>');
                if (isMCQ && btns[correctIndex]) btns[correctIndex].classList.add('correct');

                // Flash-specific visuals
                if (flipCard) flipCard.classList.add('flash-correct');
                if (okBtn) okBtn.classList.add('picked');
            } else {
                setFeedback_('<span class="error">‚úó Incorrect. Tap/click anywhere or press any key to continue</span>');

                if (isMCQ) {
                    if (chosenIndex >= 0 && btns[chosenIndex]) btns[chosenIndex].classList.add('wrong', 'selected-wrong');
                    if (btns[correctIndex]) btns[correctIndex].classList.add('correct');
                }

                // Flash-specific visuals
                if (flipCard) flipCard.classList.add('flash-incorrect');
                if (chosenIndex >= 0 && noBtn) noBtn.classList.add('picked');
                if (okBtn) okBtn.classList.add('hint'); // subtle cue for the correct button
            }

            // Disable further input for BOTH modes
            document.querySelectorAll('.answer').forEach(b => { b.disabled = true; b.classList.add('disabled'); });
            document.querySelectorAll('.fc-btn').forEach(b => { b.disabled = true; b.classList.add('disabled'); });

            // Continue-on-interaction (kept as-is)
            let continueTimer = null;
            const done = () => {
                if (continueTimer) {
                    clearTimeout(continueTimer);
                    continueTimer = null;
                }
                document.removeEventListener('keydown', onKey, true);
                document.removeEventListener('click', onClick, true);
                wasNewBeforeAnswer = false;
                goNext();
            };
            const onKey = (e) => done();
            const onClick = (e) => done();
            document.addEventListener('keydown', onKey, true);
            document.addEventListener('click', onClick, true);
            if (isCorrect) {
                continueTimer = setTimeout(done, 400);
            }
        }

        function goNext() {
            // Stop any playing audio
            _audioRequestId++;
            const audio = _audioEl || initAudioElement();
            try {
                audio.pause();
                audio.currentTime = 0;
            } catch (e) { }

            payload.state.currentIndex = decideNextIndex();
            if (payload.state.currentIndex < 0) {
                showDone(payload.state.answeredCount, payload.items.length);
                return;
            }
            setProgress();
            renderTerm();
        }

        // [2025-11-06 12:05] Final save when session completes (fire-and-forget)
        function showDone(score, totalAnswered) {
            $('quizArea').classList.add('hidden');
            $('doneArea').classList.remove('hidden');
            setFeedback_('');
            $('scoreText').textContent = `${score} / ${totalAnswered}`;
            const el = $('statusBarText');
            if (el) el.textContent = 'Done';

            // Async save
            const cardWidth = Object.keys(STUDY_SET_SCHEMA).length;
            const userProgress = payload.items.map(row => row.slice(cardWidth));
            SaveQueue.add('progress', {
                saveType: 'progress',
                data: userProgress
            });
        }

        function queueMoreNewItems(batchSize = 5) {
            if (!payload?.state) return;
            const state = payload.state;
            const extra = Number(state.extraNewItems || 0);
            state.extraNewItems = extra + batchSize;
            $('doneArea').classList.add('hidden');
            $('quizArea').classList.remove('hidden');
            goNext();
        }

        async function onSettingsSave(modalEl) {
            const newSettings = Array.isArray(settingsDraft)
                ? settingsDraft.map(r => Array.isArray(r) ? r.slice() : [])
                : [];
            const draftCopy = newSettings.map(r => Array.isArray(r) ? r.slice() : []);
            settingsDraft = null;
            if (modalEl) modalEl.hidden = true;
            setProgress();

            // Preview snapshots no longer needed after Save
            try {
                _settingsPreviewOriginal = null;
                _userPreferencesPreviewOriginal = null;
                _payloadSettingsPreviewOriginal = null;
                _payloadUserPreferencesPreviewOriginal = null;
            } catch (e) { /* ignore */ }

            // Re-render current card if one is showing
            if (payload && payload.state && payload.state.currentIndex >= 0) {
                renderTerm();
            }

            // Async save with optimistic UI
            try {
                if (settingsViewMode === 'user') {
                    // Persist only user preferences into credentials (do not overwrite deck 'settings')
                    if (!currentCredentials) currentCredentials = { email: currentCredentials?.email, password: currentCredentials?.password };
                    for (const r of draftCopy) {
                        if (!Array.isArray(r) || !r.length) continue;
                        const name = String(r[0] || '').trim();
                        const value = r[1];
                        if (name === 'ThemeLight' && value !== undefined) currentCredentials.ThemeLight = value;
                        if (name === 'AudioAutoPlay' && value !== undefined) currentCredentials.AudioAutoPlay = value;
                        if (name === 'PlaybackSpeed' && value !== undefined) currentCredentials.PlaybackSpeed = value;
                    }
                    try { ensureGlobalDefaults(currentCredentials); localStorage.setItem('userData', JSON.stringify(currentCredentials)); } catch (e) { log_('Failed to persist credentials after settings save', e); }

                    // Update in-memory preferences so UI reflects latest values immediately
                    userPreferences = draftCopy.map(r => Array.isArray(r) ? r.slice() : []);
                    if (payload) {
                        payload.userPreferences = userPreferences.map(r => Array.isArray(r) ? r.slice() : []);
                        payload.settings = [...stripGlobalSettingsFromArray(payload.settings || []), ...userPreferences];
                    }
                    const deckOnly = stripGlobalSettingsFromArray(settings || []);
                    settings = [...deckOnly, ...userPreferences.map(r => Array.isArray(r) ? r.slice() : [])];

                    // Save to server as userPreferences payload so backend writes to Users sheet
                    SaveQueue.add('userPreferences', {
                        saveType: 'userPreferences',
                        data: draftCopy
                    });
                } else {
                    // Deck-level settings
                    settings = draftCopy.map(r => Array.isArray(r) ? r.slice() : []);
                    // Update any global keys mirrored in currentCredentials
                    try {
                        if (!currentCredentials) currentCredentials = { email: currentCredentials?.email, password: currentCredentials?.password };
                        for (const r of settings) {
                            if (!Array.isArray(r) || !r.length) continue;
                            const name = String(r[0] || '').trim();
                            const value = r[1];
                            if (name === 'ThemeLight' && value !== undefined) currentCredentials.ThemeLight = value;
                            if (name === 'AudioAutoPlay' && value !== undefined) currentCredentials.AudioAutoPlay = value;
                            if (name === 'PlaybackSpeed' && value !== undefined) currentCredentials.PlaybackSpeed = value;
                        }
                        try { ensureGlobalDefaults(currentCredentials); localStorage.setItem('userData', JSON.stringify(currentCredentials)); } catch (e) { log_('Failed to persist credentials after settings save', e); }
                    } catch (e) { /* ignore */ }

                    SaveQueue.add('deckSettings', {
                        saveType: 'deckSettings',
                        data: settings
                    });
                }
            } catch (e) { log_('Failed to process settings save', e); }

            // Now that we've persisted settings into credentials and/or deck settings,
            // re-apply theme and audio state to reflect saved values (not just previewed ones)
            try { applyTheme(); } catch (e) { log_('Failed to apply theme after save', e); }
            try { initAudioStateFromSettings(); } catch (e) { log_('Failed to init audio state after save', e); }
            try { _themePreviewOriginal = null; } catch (e) { /* ignore */ }
        }


        // ---------- Startup wiring ----------
        window.addEventListener('DOMContentLoaded', () => {
            // Ensure audio element is created now that DOM is ready
            if (!_audioEl || !_audioEl.parentElement) {
                initAudioElement();
            }
            // Login modal handlers
            const loginBtn = $('loginBtn');
            const loginEmail = $('loginEmail');
            const loginPassword = $('loginPassword');
            const loginPwToggle = $('loginPwToggle');

            // Helper to attach a password visibility toggle to an input + button
            function attachPwToggle(inputEl, toggleBtn) {
                if (!inputEl || !toggleBtn) return;
                const setState = (show) => {
                    try {
                        inputEl.type = show ? 'text' : 'password';
                        toggleBtn.setAttribute('aria-pressed', show ? 'true' : 'false');
                        toggleBtn.textContent = show ? 'üôà' : 'üëÅÔ∏è';
                    } catch (e) { /* ignore */ }
                };
                // Initialize state
                setState(inputEl.type === 'text');

                toggleBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    const showing = toggleBtn.getAttribute('aria-pressed') === 'true';
                    setState(!showing);
                });

                // Support toggling via keyboard (Space/Enter)
                toggleBtn.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' || e.key === ' ') {
                        e.preventDefault();
                        toggleBtn.click();
                    }
                });
            }

            if (loginBtn) {
                loginBtn.addEventListener('click', async () => {
                    const email = loginEmail?.value?.trim() || '';
                    const password = loginPassword?.value?.trim() || '';

                    const sessionData = await attemptLogin(email, password);
                    if (sessionData) {
                        boot(sessionData);
                    }
                });
            }

            // Enter key support for login
            [loginEmail, loginPassword].forEach(input => {
                if (input) {
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') {
                            e.preventDefault();
                            loginBtn?.click();
                        }
                    });
                }
            });

            // Menu dropdown handlers
            const menuBtn = $('menuBtn');
            const menuDropdown = $('menuDropdown');
            log_('Menu elements found:', { menuBtn: !!menuBtn, menuDropdown: !!menuDropdown });

            // Enable tab/Enter/Space navigation on menu and submenu items
            document.querySelectorAll('.menu-item, .submenu-item').forEach(makeMenuItemFocusable);

            if (menuBtn && menuDropdown) {
                let menuJustOpened = false;

                menuBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    menuDropdown.hidden = !menuDropdown.hidden;

                    if (!menuDropdown.hidden) {
                        menuJustOpened = true;
                        setTimeout(() => { menuJustOpened = false; }, 100);
                    }
                });

                // Close menus when clicking outside
                document.addEventListener('click', () => {
                    if (!menuDropdown.hidden && !menuJustOpened) {
                        menuDropdown.hidden = true;
                        closeAllSubmenus();
                    }
                });

                // Prevent menu from closing when clicking inside it
                menuDropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            }

            // Close all submenus helper (define first)
            const studySetSubmenu = $('studySetSubmenu');
            const suspendSubmenu = $('suspendSubmenu');
            const closeAllSubmenus = () => {
                if (studySetSubmenu) studySetSubmenu.hidden = true;
                if (suspendSubmenu) suspendSubmenu.hidden = true;
                if (settingsOptionsSubmenu) settingsOptionsSubmenu.hidden = true;
            };

            // Menu item handlers
            const studySetMenuItem = $('studySetMenuItem');
            const testModeMenuItem = $('testModeMenuItem');
            const suspendMenuItem = $('suspendMenuItem');
            const settingsMenuItem = $('settingsMenuItem');
            const settingsOptionsSubmenu = $('settingsOptionsSubmenu');
            const setSettingsOption = $('setSettingsOption');
            const userPreferencesOption = $('userPreferencesOption');
            // settingsViewMode is declared globally; don't redeclare here

            function positionSubmenuAtMenuItem(submenu, menuItem) {
                if (!submenu || !menuItem || !menuDropdown) return;
                try {
                    // Ensure submenu is visible so getBoundingClientRect() returns dimensions
                    submenu.hidden = false;
                    const menuRect = menuDropdown.getBoundingClientRect();
                    const itemRect = menuItem.getBoundingClientRect();
                    const left = Math.min(Math.max(menuRect.right + 6, 8), window.innerWidth - 160);
                    // position submenu roughly aligned with the clicked menu item vertically
                    let top = itemRect.top - 6;
                    // Avoid going off-screen vertically
                    const maxTop = Math.max(8, window.innerHeight - (submenu.getBoundingClientRect().height || 200) - 8);
                    if (top > maxTop) top = maxTop;
                    if (top < 8) top = 8;
                    submenu.style.left = left + 'px';
                    submenu.style.top = top + 'px';
                } catch (e) { /* ignore positioning errors */ }
            }

            if (studySetMenuItem && studySetSubmenu) {
                studySetMenuItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const hasNoSets = payload && payload.availableSets && payload.availableSets.length === 0;
                    if (hasNoSets) {
                        const adminEmail = payload.adminEmail || 'administrator';
                        alert(`No study sets available. Contact admin (${adminEmail}) to enable access.`);
                        if (menuDropdown) menuDropdown.hidden = true;
                        return;
                    }
                    closeAllSubmenus();
                    positionSubmenuAtMenuItem(studySetSubmenu, studySetMenuItem);
                });
            }

            if (suspendMenuItem && suspendSubmenu) {
                suspendMenuItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    populateSuspendBands();
                    closeAllSubmenus();
                    positionSubmenuAtMenuItem(suspendSubmenu, suspendMenuItem);
                });
            }

            if (testModeMenuItem) {
                testModeMenuItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (menuDropdown) menuDropdown.hidden = true;
                    closeAllSubmenus();

                    const hasNoSets = payload && payload.availableSets && payload.availableSets.length === 0;
                    if (hasNoSets) {
                        const adminEmail = payload.adminEmail || 'administrator';
                        alert(`No study sets available. Contact admin (${adminEmail}) to enable access.`);
                        return;
                    }

                    if (testState) {
                        exitTestMode();
                    } else {
                        startTestMode();
                    }
                });
            }

            if (settingsMenuItem) {
                settingsMenuItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // Do NOT hide the main menu; open the right-side submenu next to it (like Study Set)
                    closeAllSubmenus();
                    if (settingsOptionsSubmenu) {
                        // Position submenu next to the clicked menu item
                        positionSubmenuAtMenuItem(settingsOptionsSubmenu, settingsMenuItem);
                    }
                });
            }
            if (setSettingsOption) {
                setSettingsOption.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    // show deck-level settings (from IndexedDB if available, fallback to payload.settings)
                    const active = payload?.activeSet || currentCredentials?.activeSet;
                    if (!active) {
                        showToast('No active deck selected', 'error');
                        return;
                    }
                    let deckData = null;
                    try {
                        if (typeof DeckCache !== 'undefined' && active) {
                            deckData = await DeckCache.get(active);
                        }
                    } catch (err) {
                        log_('Failed to read deck cache:', err);
                    }
                    let draft = [];
                    if (deckData && Array.isArray(deckData.userSettings) && deckData.userSettings.length) {
                        draft = deckData.userSettings.map(r => Array.isArray(r) ? r.slice() : []);
                    } else if (Array.isArray(payload?.settings)) {
                        draft = payload.settings.map(r => Array.isArray(r) ? r.slice() : []);
                    } else {
                        draft = [];
                    }
                    // Remove global settings from deck-level settings. Keep UserID in the data so
                    // it is persisted, but it will be hidden in the UI by renderSettingsUI().
                    draft = stripGlobalSettingsFromArray(draft);
                    settingsDraft = draft;
                    settingsViewMode = 'set';
                    // Snapshot current in-memory state so Cancel can revert
                    _settingsPreviewOriginal = cloneSettingsMatrix_(settings);
                    _userPreferencesPreviewOriginal = cloneSettingsMatrix_(userPreferences);
                    _payloadSettingsPreviewOriginal = cloneSettingsMatrix_(payload?.settings);
                    _payloadUserPreferencesPreviewOriginal = cloneSettingsMatrix_(payload?.userPreferences);
                    // Capture original theme for revert on cancel
                    try {
                        _themePreviewOriginal = (function () {
                            try { return getSetting(THEME_SETTING_NAME); } catch (e) { return currentCredentials?.ThemeLight; }
                        })();
                    } catch (e) { _themePreviewOriginal = (document.body && document.body.dataset && document.body.dataset.theme === 'light'); }
                    renderSettingsUI({ settings: settingsDraft });
                    try { document.querySelector('#settingsWrap h3').textContent = 'Set Settings'; } catch (e) { /* ignore */ }
                    try { $('settingsHint').textContent = `Deck: ${active}`; } catch (e) { /* ignore */ }
                    try {
                        const themeRow = (settingsDraft || []).find(r => Array.isArray(r) && String(r[0]) === 'ThemeLight');
                        applyTheme(themeRow ? themeRow[1] : undefined);
                    } catch (e) { applyTheme(); }
                    // Close the main menu when opening the modal
                    if (menuDropdown) menuDropdown.hidden = true;
                    $('settingsModal').hidden = false;
                    if (settingsOptionsSubmenu) settingsOptionsSubmenu.hidden = true;
                });
            }

            if (userPreferencesOption) {
                userPreferencesOption.addEventListener('click', (e) => {
                    e.stopPropagation();
                    // show user preferences from latest in-memory state or credentials
                    const creds = ensureGlobalDefaults(currentCredentials || {});
                    const prefs = (Array.isArray(userPreferences) && userPreferences.length)
                        ? userPreferences.map(r => Array.isArray(r) ? r.slice() : [])
                        : [
                            ['Setting', 'Value'],
                            ['UserID', creds.email || currentCredentials?.email || ''],
                            ['ThemeLight', creds.ThemeLight],
                            ['AudioAutoPlay', creds.AudioAutoPlay],
                            ['PlaybackSpeed', creds.PlaybackSpeed]
                        ];
                    settingsDraft = prefs.map(r => Array.isArray(r) ? r.slice() : []);
                    settingsViewMode = 'user';
                    // Snapshot current in-memory state so Cancel can revert
                    _settingsPreviewOriginal = cloneSettingsMatrix_(settings);
                    _userPreferencesPreviewOriginal = cloneSettingsMatrix_(userPreferences);
                    _payloadSettingsPreviewOriginal = cloneSettingsMatrix_(payload?.settings);
                    _payloadUserPreferencesPreviewOriginal = cloneSettingsMatrix_(payload?.userPreferences);
                    renderSettingsUI({ settings: settingsDraft });
                    try { document.querySelector('#settingsWrap h3').textContent = 'User Preferences'; } catch (e) { /* ignore */ }
                    try { $('settingsHint').textContent = 'Preferences saved to your account'; } catch (e) { /* ignore */ }
                    try {
                        _themePreviewOriginal = (function () {
                            try { return getSetting(THEME_SETTING_NAME); } catch (e) { return currentCredentials?.ThemeLight; }
                        })();
                    } catch (e) { _themePreviewOriginal = (document.body && document.body.dataset && document.body.dataset.theme === 'light'); }
                    try {
                        const themeRow = (settingsDraft || []).find(r => Array.isArray(r) && String(r[0]) === 'ThemeLight');
                        applyTheme(themeRow ? themeRow[1] : undefined);
                    } catch (e) { applyTheme(); }
                    // Close the main menu when opening the modal
                    if (menuDropdown) menuDropdown.hidden = true;
                    $('settingsModal').hidden = false;
                    if (settingsOptionsSubmenu) settingsOptionsSubmenu.hidden = true;
                });
            }

            // Change password menu item
            const changePasswordMenuItem = $('changePasswordMenuItem');
            const changePasswordModal = $('changePasswordModal');
            const cpCurrent = $('cpCurrent');
            const cpNew = $('cpNew');
            const cpConfirm = $('cpConfirm');
            const cpError = $('cpError');
            const cpSaveBtn = $('changePasswordSaveBtn');
            const cpCancelBtn = $('changePasswordCancelBtn');
            const cpCurrentToggle = $('cpCurrentToggle');
            const cpNewToggle = $('cpNewToggle');
            const cpConfirmToggle = $('cpConfirmToggle');

            // Attach reveal toggles to login and change-password inputs
            try {
                attachPwToggle(loginPassword, loginPwToggle);
                attachPwToggle(cpCurrent, cpCurrentToggle);
                attachPwToggle(cpNew, cpNewToggle);
                attachPwToggle(cpConfirm, cpConfirmToggle);
            } catch (e) {
                log_('attachPwToggle failed', e);
            }

            if (changePasswordMenuItem) {
                changePasswordMenuItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (menuDropdown) menuDropdown.hidden = true;
                    closeAllSubmenus();
                    if (!currentCredentials || !currentCredentials.email) {
                        showLoginModal();
                        return;
                    }
                    if (cpCurrent) cpCurrent.value = '';
                    if (cpNew) cpNew.value = '';
                    if (cpConfirm) cpConfirm.value = '';
                    if (cpError) { cpError.style.display = 'none'; cpError.textContent = ''; }
                    if (changePasswordModal) changePasswordModal.hidden = false;
                    setTimeout(() => cpCurrent?.focus(), 50);
                });
            }

            if (cpCancelBtn) cpCancelBtn.addEventListener('click', () => {
                if (changePasswordModal) changePasswordModal.hidden = true;
            });

            if (cpSaveBtn) cpSaveBtn.addEventListener('click', async () => {
                try {
                    if (!currentCredentials || !currentCredentials.email) {
                        if (cpError) { cpError.textContent = 'Not logged in'; cpError.style.display = 'block'; }
                        return;
                    }
                    const cur = cpCurrent?.value || '';
                    const nw = cpNew?.value || '';
                    const conf = cpConfirm?.value || '';
                    if (!cur || !nw || !conf) {
                        if (cpError) { cpError.textContent = 'Fill all fields'; cpError.style.display = 'block'; }
                        return;
                    }
                    if (nw !== conf) {
                        if (cpError) { cpError.textContent = 'New passwords do not match'; cpError.style.display = 'block'; }
                        return;
                    }
                    if (nw.length < 6) {
                        if (cpError) { cpError.textContent = 'Password too short (min 6)'; cpError.style.display = 'block'; }
                        return;
                    }

                    cpSaveBtn.disabled = true;
                    const resp = await service.changePassword({ userId: currentCredentials.email, currentPassword: cur, newPassword: nw });
                    cpSaveBtn.disabled = false;
                    if (resp && resp.success) {
                        // Update local stored credentials
                        saveCredentials(currentCredentials.email, nw, currentCredentials.activeSet);
                        if (changePasswordModal) changePasswordModal.hidden = true;
                        showToast('Password changed', 'info');
                    } else {
                        const err = resp && resp.error ? resp.error : 'UNKNOWN_ERROR';
                        if (cpError) { cpError.textContent = String(err); cpError.style.display = 'block'; }
                    }
                } catch (e) {
                    cpSaveBtn.disabled = false;
                    if (cpError) { cpError.textContent = String(e.message || e); cpError.style.display = 'block'; }
                }
            });

            // Feedback modal handlers
            const feedbackMenuItem = $('feedbackMenuItem');
            const feedbackModal = $('feedbackModal');
            const feedbackText = $('feedbackText');
            const feedbackCharCount = $('feedbackCharCount');
            const feedbackSendBtn = $('feedbackSendBtn');
            const feedbackCancelBtn = $('feedbackCancelBtn');

            if (feedbackMenuItem && feedbackModal && feedbackText) {
                feedbackMenuItem.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (menuDropdown) menuDropdown.hidden = true;
                    closeAllSubmenus();
                    feedbackText.value = '';
                    if (feedbackCharCount) feedbackCharCount.textContent = '0';
                    if (feedbackSendBtn) {
                        feedbackSendBtn.disabled = false;
                        feedbackSendBtn.textContent = 'Send';
                    }
                    feedbackModal.hidden = false;
                    setTimeout(() => feedbackText.focus(), 100);
                });
            }

            if (feedbackText && feedbackCharCount) {
                feedbackText.addEventListener('input', () => {
                    const len = feedbackText.value.length;
                    feedbackCharCount.textContent = String(len);
                    if (len > 1000) {
                        feedbackText.value = feedbackText.value.substring(0, 1000);
                        feedbackCharCount.textContent = '1000';
                    }
                });
            }

            if (feedbackCancelBtn && feedbackModal) {
                feedbackCancelBtn.addEventListener('click', () => {
                    feedbackModal.hidden = true;
                });
            }

            if (feedbackSendBtn && feedbackModal && feedbackText) {
                feedbackSendBtn.addEventListener('click', async () => {
                    const message = feedbackText.value.trim();
                    if (!message) {
                        alert('Please enter your feedback');
                        return;
                    }

                    const userId = currentCredentials?.email || 'unknown';
                    const currentSet = payload?.activeSet || '';

                    // Show success immediately (optimistic UI)
                    feedbackModal.hidden = true;

                    // Async save
                    SaveQueue.add('feedback', {
                        saveType: 'feedback',
                        feedbackData: {
                            userId,
                            currentSet,
                            message
                        }
                    });
                });
            }

            // Suspend modal handlers
            const suspendModal = $('suspendModal');
            const suspendCancelBtn = $('suspendCancelBtn');
            const suspendSaveBtn = $('suspendSaveBtn');

            if (suspendCancelBtn && suspendModal) {
                suspendCancelBtn.addEventListener('click', () => {
                    suspendModal.hidden = true;
                });
            }

            if (suspendSaveBtn && suspendModal) {
                suspendSaveBtn.addEventListener('click', () => {
                    const C = payload.schema.lexiconCols;
                    const checkboxes = suspendModal.querySelectorAll('input[type="checkbox"]');

                    checkboxes.forEach(cb => {
                        const index = parseInt(cb.dataset.index);
                        if (index >= 0 && index < payload.items.length) {
                            payload.items[index][C.suspended] = cb.checked;
                        }
                    });

                    suspendModal.hidden = true;

                    // Update stats to reflect suspended cards
                    updateSessionStats();

                    // Async save
                    const cardWidth = Object.keys(STUDY_SET_SCHEMA).length;
                    const userProgress = payload.items.map(row => row.slice(cardWidth));
                    SaveQueue.add('progress', {
                        saveType: 'progress',
                        data: userProgress
                    });
                });
            }

            // Settings modal handlers
            const modal = $('settingsModal');
            const backdrop = $('settingsBackdrop');
            const btnSave = $('settingsSaveBtn');
            const btnCancel = $('settingsCancelBtn');
            if (backdrop) backdrop.addEventListener('click', (e) => { e.stopPropagation(); });
            window.addEventListener('keydown', (e) => {
                if (e.key === 'Escape' && !modal.hidden) {
                    e.preventDefault();
                }
            });
            if (btnCancel && modal) btnCancel.addEventListener('click', () => {
                settingsDraft = null;
                modal.hidden = true;
                try { applyTheme(_themePreviewOriginal); } catch (e) { log_('Failed to revert theme on cancel', e); }
                // Revert any previewed setting changes
                try {
                    if (_settingsPreviewOriginal) settings = cloneSettingsMatrix_(_settingsPreviewOriginal);
                    if (_userPreferencesPreviewOriginal) userPreferences = cloneSettingsMatrix_(_userPreferencesPreviewOriginal);
                    if (payload) {
                        if (_payloadSettingsPreviewOriginal) payload.settings = cloneSettingsMatrix_(_payloadSettingsPreviewOriginal);
                        if (_payloadUserPreferencesPreviewOriginal) payload.userPreferences = cloneSettingsMatrix_(_payloadUserPreferencesPreviewOriginal);
                    }
                    if (testState) {
                        renderTestQuestion();
                    } else {
                        updateSessionStats();
                        if (payload && payload.state && payload.state.currentIndex >= 0) renderTerm();
                    }
                } catch (e) {
                    log_('Failed to revert settings preview on cancel', e);
                }
                try { _themePreviewOriginal = null; } catch (e) { /* ignore */ }
                try {
                    _settingsPreviewOriginal = null;
                    _userPreferencesPreviewOriginal = null;
                    _payloadSettingsPreviewOriginal = null;
                    _payloadUserPreferencesPreviewOriginal = null;
                } catch (e) { /* ignore */ }
            });
            if (btnSave && modal) btnSave.addEventListener('click', () => onSettingsSave(modal));
            const extraBtn = $('extraNewBtn');
            if (extraBtn) extraBtn.addEventListener('click', () => queueMoreNewItems(5));

            // Logout menu item handler
            const logoutMenuItem = $('logoutMenuItem');
            if (logoutMenuItem) {
                logoutMenuItem.addEventListener('click', async (e) => {
                    e.stopPropagation();
                    if (menuDropdown) menuDropdown.hidden = true;
                    closeAllSubmenus();

                    // Clear all state
                    await clearClientStorage();
                    clearCredentials();
                    payload = null;
                    settings = [];
                    testState = null;

                    // Hide quiz/done areas to clear background
                    $('quizArea').classList.add('hidden');
                    $('doneArea').classList.add('hidden');

                    // Clear status bar
                    const sb = $('statusBarText');
                    if (sb) sb.textContent = '';

                    showLoginModal();
                });
            }

            // Restore pending saves from previous session
            SaveQueue.restore();

            // Try to auto-login with stored credentials, otherwise show login modal
            const stored = loadCredentials();
            if (stored && stored.email && stored.password) {
                boot().catch(err => {
                    log_('Auto-login failed:', err);
                    showLoginModal();
                });
            } else {
                showLoginModal();
            }
        });
        window.addEventListener('orientationchange', () => setTimeout(autoshrinkAll, 50));
        window.addEventListener('resize', () => setTimeout(autoshrinkAll, 50));

        /* ---------- Text-fit helpers ---------- */
        function fitTextToBox(el, { max = 28, min = 14, step = 0.5 } = {}) {
            if (!el) return;
            const parent = el.parentElement;
            if (!parent) return;

            let size = max;
            el.style.fontSize = size + 'px';

            const fits = () => {
                const heightFits = el.scrollHeight <= parent.clientHeight;
                const widthFits = el.scrollWidth <= parent.clientWidth;
                return heightFits && widthFits;
            };

            let guard = 200;
            while (!fits() && size > min && guard-- > 0) {
                size -= step;
                el.style.fontSize = size + 'px';
            }
        }
        function autoshrinkAll() {
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    // First, fit the term text independently
                    const termEl = $('termText');
                    if (termEl && termEl.textContent) {
                        const termHeader = $('termHeader');
                        if (termHeader) {
                            const textLen = termEl.textContent.trim().length;
                            let size = textLen <= 3 ? 80 : (textLen <= 10 ? 48 : 28);
                            termEl.style.fontSize = size + 'px';
                            let guard = 200;
                            while (termEl.scrollHeight > termHeader.clientHeight && size > 8 && guard-- > 0) {
                                size -= 0.5;
                                termEl.style.fontSize = size + 'px';
                            }
                        }
                    }

                    // Then fit answer labels
                    const labelNodes = Array.from(document.querySelectorAll('.answer-label'));
                    let smallest = null;
                    labelNodes.forEach(el => {
                        const textLen = el.textContent.trim().length;
                        const maxSize = textLen <= 3 ? 60 : (textLen <= 10 ? 40 : 24);
                        fitTextToBox(el, { max: maxSize, min: 6, step: 0.5 });
                        const size = parseFloat(window.getComputedStyle(el).fontSize) || null;
                        if (!size) return;
                        if (smallest === null || size < smallest) {
                            smallest = size;
                        }
                    });
                    if (smallest !== null) {
                        labelNodes.forEach(el => {
                            el.style.fontSize = smallest + 'px';
                        });
                    }

                    // Fit flashcard faces
                    document.querySelectorAll('.flip-face').forEach(el => {
                        const textLen = el.textContent.trim().length;
                        const maxSize = textLen <= 3 ? 120 : (textLen <= 10 ? 80 : 38);
                        fitTextToBox(el, { max: maxSize, min: 12, step: 0.5 });
                    });
                });
            });
        }

    </script>
</body>

</html>
